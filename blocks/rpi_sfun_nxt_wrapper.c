/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue Jan 28 17:36:03 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

#ifndef MATLAB_MEX_FILE
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <libusb-1.0/libusb.h>
#include "nxtusb.h"
#endif
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
#ifndef MATLAB_MEX_FILE

#define NXT_INTERFACE_NUMBER        0
#define NXT_EP_OUT                  0x01
#define NXT_EP_IN                   0x82
#define NXT_PACKET_SIZE							64
#define NXT_VENDOR_LEGO             0x0694
#define NXT_PRODUCT_NXT             0x0002
#define NXT_SERIAL_NO_SIZE					12
#define NXT_MAX_ID                  9

/* Error codes */
#define NXT_OK                      0
#define NXT_USB_ERROR								1
#define NXT_NOT_PRESENT             2
#define NXT_CONFIGURATION_ERROR     3
#define NXT_IN_USE                  4
#define NXT_USB_WRITE_ERROR         5
#define NXT_USB_READ_ERROR          6
#define NXT_USB_PARTIAL_TRANS				7
#define NXT_USB_OVERFLOW						9
#define NXT_BYTECODE_ERROR          10
#define NXT_INTERNAL_ERROR					11

typedef int												nxt_error_t;

struct libusb_device_handle				*nxt_hdl[NXT_MAX_ID];

unsigned char											init_flag = 0;
unsigned char											nxt_data[NXT_PACKET_SIZE];
struct nxt_control_struct					*nxt_control = NULL;
struct nxt_measurement_struct			*nxt_measurement = NULL;


nxt_error_t nxt_find_and_open( unsigned int id )  {
	libusb_device 										*dev, **devs;
	struct libusb_device_descriptor		desc;
	int																i, j, status, transfered;
	unsigned char	                  	tmpbuf[NXT_PACKET_SIZE];
	char															serial[NXT_SERIAL_NO_SIZE+1];
	char															expected_serial[NXT_SERIAL_NO_SIZE+1];

	if ( libusb_get_device_list( NULL, &devs ) < 0 )
		return NXT_USB_ERROR;
  
  if ( id > NXT_MAX_ID )
    return NXT_INTERNAL_ERROR;
	
	/* Go through device list loooking for an NXT device */
	for ( i = 0; ( dev = devs[i] ) != NULL; i++ ) {
		
		status = libusb_get_device_descriptor( dev, &desc );
		
		if ( status >= 0 ) {
			if ( 	( desc.idVendor == NXT_VENDOR_LEGO ) &&
						( desc.idProduct == NXT_PRODUCT_NXT ) )	{
				
				/* Open the device */
				status = libusb_open( dev, &nxt_hdl[id] );
				if ( status < 0 )	{
					libusb_free_device_list( devs, 1 );
					return NXT_USB_ERROR;
				}
				
				/* Check the serial number */
				
				for ( j = 0; j < NXT_SERIAL_NO_SIZE; j++ )
					expected_serial[j] = 0x30 + id;
				expected_serial[NXT_SERIAL_NO_SIZE] = 0;
				status = libusb_get_string_descriptor_ascii( nxt_hdl[id], desc.iSerialNumber, (unsigned char*)serial, sizeof( serial ) );
				if ( status == NXT_SERIAL_NO_SIZE ) {
					if ( strcmp( expected_serial, serial ) )	{
						libusb_close( nxt_hdl[id] );
            nxt_hdl[id] = NULL;
						continue;
					}
				}
				else {
					libusb_close( nxt_hdl[id] ); 
          nxt_hdl[id] = NULL;
					continue;
				}
				
				/* Detach possible kernel driver bound to interface */
				libusb_detach_kernel_driver( nxt_hdl[id], NXT_INTERFACE_NUMBER );
				
				/* Claiming the interface */
				status = libusb_claim_interface( nxt_hdl[id], NXT_INTERFACE_NUMBER );
				if ( status )	{
					libusb_close( nxt_hdl[id] );
          nxt_hdl[id] = NULL;
					libusb_free_device_list( devs, 1 );
					return NXT_IN_USE;
				}
				
				/* Request a packet until getting a zero byte packet */
				do
				{
					status = libusb_bulk_transfer( nxt_hdl[id], NXT_EP_IN, tmpbuf, NXT_PACKET_SIZE, &transfered, NXT_TIMEOUT_MS );
				} while ( ( status == 0 ) && ( transfered != 0 ) ); 
				
				libusb_free_device_list( devs, 1 );
				return NXT_OK;
			}
		}
	}
	
	libusb_free_device_list( devs, 1 );
	return NXT_NOT_PRESENT;
}

nxt_error_t nxt_close( unsigned int id )  {
  int i;
	
	if ( nxt_hdl[id] == NULL )
		return NXT_CONFIGURATION_ERROR;
	
	libusb_release_interface( nxt_hdl[id], NXT_INTERFACE_NUMBER );
	libusb_close( nxt_hdl[id] );
	nxt_hdl[id] = NULL;
  
  /* Check if all devices are closed */
  
  for ( i = 0; i < NXT_MAX_ID; i++ )
    if ( nxt_hdl[i] )
      break;
  
  if ( i == NXT_MAX_ID ) {
    libusb_exit( NULL );
    init_flag =0;
  }

	return NXT_OK;
}

nxt_error_t nxt_send_buf( unsigned int id )  {
	int	status, transfered1 = 0, transfered2 = 0;
	
	if ( nxt_hdl[id] == NULL )
		return NXT_CONFIGURATION_ERROR;
	
	status = libusb_bulk_transfer( nxt_hdl[id], NXT_EP_OUT, nxt_data, NXT_PACKET_SIZE, &transfered1, NXT_TIMEOUT_MS );

	if ( status  )
		return NXT_USB_WRITE_ERROR;
	
	if ( transfered1 != NXT_PACKET_SIZE )	{
		
		/* Give a second try in case of partial transfer */
		
		status = libusb_bulk_transfer( nxt_hdl[id], NXT_EP_OUT, &nxt_data[transfered1], NXT_PACKET_SIZE - transfered1, &transfered2, NXT_TIMEOUT_MS / 2 );
		
		if ( status  )
			return NXT_USB_WRITE_ERROR;
		
		if ( transfered1 + transfered2 != NXT_PACKET_SIZE )
			return NXT_USB_PARTIAL_TRANS;
	}

	return NXT_OK;
}

nxt_error_t nxt_recv_buf( unsigned int id )  {
	int	 status, transfered1 = 0, transfered2 = 0;
	
	if ( nxt_hdl[id] == NULL )
		return NXT_CONFIGURATION_ERROR;
	
	status = libusb_bulk_transfer( nxt_hdl[id], NXT_EP_IN, nxt_data, NXT_PACKET_SIZE, &transfered1, NXT_TIMEOUT_MS );

	if ( status  )
		return NXT_USB_READ_ERROR;
	
	if ( transfered1 != NXT_PACKET_SIZE )	{
		
		/* Give a second try in case of partial transfer */
		
		status = libusb_bulk_transfer( nxt_hdl[id], NXT_EP_IN, &nxt_data[transfered1], NXT_PACKET_SIZE - transfered1, &transfered2, NXT_TIMEOUT_MS / 2 );
		
		if ( status  )
			return NXT_USB_READ_ERROR;
		
		if ( transfered1 + transfered2 != NXT_PACKET_SIZE )
			return NXT_USB_PARTIAL_TRANS;
	}

	return NXT_OK;
}

nxt_error_t nxt_init( unsigned int id )  {
	int status, i;
	
	/* Only once initializations */
	
	if ( !init_flag ) {
		
		/* Initialize pointers */
    
    for ( i = 0; i < NXT_MAX_ID; i++ )
      nxt_hdl[i] = NULL;
	
		nxt_control = (struct nxt_control_struct*)nxt_data;
		nxt_measurement = (struct nxt_measurement_struct*)nxt_data;
	
		/* Check boundaries */
	
		if ( 	( sizeof( struct nxt_control_struct ) > NXT_PACKET_SIZE ) ||
					( sizeof( struct nxt_measurement_struct ) > NXT_PACKET_SIZE ) )
			return NXT_INTERNAL_ERROR;
	
		/* Fill the data buffer with zeros */
			
		memset( nxt_data, 0, NXT_PACKET_SIZE );
	
		/* Initialize USB */
	
		status = libusb_init( NULL );
	
		if ( status ) 
			return NXT_USB_ERROR;
			
		init_flag = 1;
	}
	
	/* Look for an NXT in USB devices list and open it if found */
	
	status = nxt_find_and_open( id );
	if ( status )
		return status;
	
	/* Init encoders */

	for ( i = 0; i < NXT_NB_MOTORS; i++ )
			nxt_control->motor_power[i] = 0;
	nxt_control->init_encoders = 1;
	
	status = nxt_send_buf( id );
	if ( status ) 
		return status;
	
	status = nxt_recv_buf( id );
	if ( status != NXT_OK )
		return status;

	return NXT_OK;
}

nxt_error_t 	nxt_iteration(
							unsigned int 	id,
							double 				*motor_power, 
							double 				*motor_angle, 
							double 				*input_ADC, 
							double 				*battery_voltage )  {
								
	nxt_error_t	 						status;
	int											i;
	double									control = 0.0;
	static double						last_motor_angle[NXT_MAX_ID][NXT_NB_MOTORS],
													last_input_ADC[NXT_MAX_ID][NXT_NB_SENSORS],
													last_battery_voltage[NXT_MAX_ID];
	static unsigned char 		last_init_flag[NXT_MAX_ID] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	
	/* Initialize last values */
	
	if ( !last_init_flag[id] ) {
		for ( i = 0; i < NXT_NB_MOTORS; i++ )
			last_motor_angle[id][i] = 0.0;
		for ( i = 0; i < NXT_NB_SENSORS; i++ )
			last_input_ADC[id][i] = 0.0;
		last_battery_voltage[id] = 0.0;
		last_init_flag[id] = 1;
	}
	
	/* Chack if USB is initialized */
	
	if ( 	( nxt_hdl[id] == NULL ) || 
				( nxt_control == NULL ) || 
				( nxt_measurement == NULL ) ) {
		
		for ( i = 0; i < NXT_NB_MOTORS; i++ )
			motor_angle[i] = last_motor_angle[id][i];
		for ( i = 0; i < NXT_NB_SENSORS; i++ )
			input_ADC[i] = last_input_ADC[id][i];
		*battery_voltage = last_battery_voltage[id];
		
		return NXT_CONFIGURATION_ERROR;
	}
		
	/* Fill the control signal values */
	
	for ( i = 0; i < NXT_NB_MOTORS; i++ ) {
		
		control = motor_power[i] ;
		
		/* NaN detection */
		
		if ( isnan( control ) )
			control = 0.0;
		
		/* Saturation */
		
		if ( control > NXT_MAX_CONTROL )
			control = NXT_MAX_CONTROL;
		if ( control < -NXT_MAX_CONTROL )
			control = -NXT_MAX_CONTROL;
		
		nxt_control->motor_power[i] = (signed char)trunc( control );
	}
		
	/* Define encoder init flag */
		
	nxt_control->init_encoders = 0;
	
	/* Transmit packet */
		
	status = nxt_send_buf( id );
	if ( status ) {
		for ( i = 0; i < NXT_NB_MOTORS; i++ )
			motor_angle[i] = last_motor_angle[id][i];
		for ( i = 0; i < NXT_NB_SENSORS; i++ )
			input_ADC[i] = last_input_ADC[id][i];
		*battery_voltage = last_battery_voltage[id];
			
		return status;
	}
	
	/* Read response */
	
	status = nxt_recv_buf( id );
	if ( status ) {
		for ( i = 0; i < NXT_NB_MOTORS; i++ )
			motor_angle[i] = last_motor_angle[id][i];
		for ( i = 0; i < NXT_NB_SENSORS; i++ )
			input_ADC[i] = last_input_ADC[id][i];
		*battery_voltage = last_battery_voltage[id];
			
		return status;
	}
	
	/* Fill response */
	
	for ( i = 0; i < NXT_NB_MOTORS; i++ ) {
		motor_angle[i] = nxt_measurement->motor_angle[i];
		last_motor_angle[id][i] = nxt_measurement->motor_angle[i];
	}
	for ( i = 0; i < NXT_NB_SENSORS; i++ ) {
		input_ADC[i] = nxt_measurement->input_ADC[i];
		last_input_ADC[id][i] = nxt_measurement->input_ADC[i];
	}
	*battery_voltage = nxt_measurement->battery_voltage;
	last_battery_voltage[id] = nxt_measurement->battery_voltage;
		
	return NXT_OK;
}

#endif
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void rpi_sfun_nxt_Outputs_wrapper(const real_T *u_A,
                          const real_T *u_B,
                          const real_T *u_C,
                          real_T *y_A,
                          real_T *y_B,
                          real_T *y_C,
                          real_T *y_1,
                          real_T *y_2,
                          real_T *y_3,
                          real_T *y_4,
                          real_T *bat  , 
                          const real_T  *rpi_Ts, const int_T  p_width0, 
                          const uint32_T  *rpi_id,  const int_T p_width1)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
#ifdef MATLAB_MEX_FILE

y_A[0] = 0.0;
y_B[0] = 0.0;
y_C[0] = 0.0;
y_1[0] = 0.0;
y_2[0] = 0.0;
y_3[0] = 0.0;
y_4[0] = 0.0;
bat[0] = 0.0;

#else

real_T        motor_power[NXT_NB_MOTORS], 
              motor_angle[NXT_NB_MOTORS],
              input_ADC[NXT_NB_SENSORS],
              battery_voltage;
nxt_error_t   status;

if ( ( p_width0 > 1 ) || ( p_width1 > 1 ) )	{
  fprintf( stderr, "** Multiple rates not allowed in this block **\n" );
  y_A[0] = 0.0;
  y_B[0] = 0.0;
  y_C[0] = 0.0;
  y_1[0] = 0.0;
  y_2[0] = 0.0;
  y_3[0] = 0.0;
  y_4[0] = 0.0;
  bat[0] = 0.0;
  return;
}

if ( *rpi_id > 9 )	{
  fprintf( stderr, "** Max NXT ID = 9 **\n" );
  y_A[0] = 0.0;
  y_B[0] = 0.0;
  y_C[0] = 0.0;
  y_1[0] = 0.0;
  y_2[0] = 0.0;
  y_3[0] = 0.0;
  y_4[0] = 0.0;
  bat[0] = 0.0;
  return;
}

if ( *rpi_Ts < 0.001 )	{
  fprintf( stderr, "** Max sampling rate = 1000Hz **\n" );
  y_A[0] = 0.0;
  y_B[0] = 0.0;
  y_C[0] = 0.0;
  y_1[0] = 0.0;
  y_2[0] = 0.0;
  y_3[0] = 0.0;
  y_4[0] = 0.0;
  bat[0] = 0.0;
  return;
}

motor_power[0] = u_A[0];
motor_power[1] = u_B[0];
motor_power[2] = u_C[0];

status = nxt_iteration( *rpi_id, motor_power, motor_angle, input_ADC, &battery_voltage );

if ( status ) {
  fprintf( stderr, "** nxt_iteration on NXT id=%d failed with error %d **\n", *rpi_id, status );
  y_A[0] = 0.0;
  y_B[0] = 0.0;
  y_C[0] = 0.0;
  y_1[0] = 0.0;
  y_2[0] = 0.0;
  y_3[0] = 0.0;
  y_4[0] = 0.0;
  bat[0] = 0.0;
}
else  {
  y_A[0] = motor_angle[0];
  y_B[0] = motor_angle[1];
  y_C[0] = motor_angle[2];
  y_1[0] = input_ADC[0];
  y_2[0] = input_ADC[1];
  y_3[0] = input_ADC[2];
  y_4[0] = input_ADC[3];
  bat[0] = battery_voltage;
}

#endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
