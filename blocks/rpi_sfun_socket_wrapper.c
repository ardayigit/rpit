/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue May 10 16:47:07 2016
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#if defined(MATLAB_MEX_FILE)
#include <math.h>
#else
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <signal.h>
#include <pthread.h>
#include <time.h>
#endif
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
#ifndef MATLAB_MEX_FILE
//#define RPIT_SOCKET_DISPLAY_MES

/* Check that these definitions are identical in server code */

#define RPIT_SOCKET_N							10			// Nb of double returned
#define RPIT_SOCKET_PORT					"31415"	// Port of the sever
#define RPIT_SOCKET_MAGIC					"RPIt"	// Magic string			
																					// Size of the packet buffer																		
#define RPIT_SOCKET_BUF_SIZE			sizeof( RPIT_SOCKET_MAGIC )
#define RPIT_SOCKET_PERIOD				2000		// Sampling period of the measurement (us)
#define RPIT_SIZEOF_IP            20      // Size of an IP address

struct RPIt_socket_struct	{
	unsigned long long 	timestamp;					// Absolute server time in ns 
	double							mes[RPIT_SOCKET_N];	// Measurements
};

pthread_t 								mes_thread;
pthread_mutex_t 					mes_mutex;
struct RPIt_socket_struct	mes;
int												sfd = 0;				// Socket file descriptor

#define RPIT_SOCKET_TIMEOUT				80000		// Server answering timeout in us

/* 
 * rpit_socket_client_update : thread communicating with the server
 */
void* rpit_socket_client_update( void* ptr )	{
	ssize_t                   nread;
	struct timespec           before_time, after_time;
	unsigned long long        period;
  struct RPIt_socket_struct	local_mes;
	#ifdef RPIT_SOCKET_DISPLAY_MES
	int                       i;
	#endif
	
  if ( ptr )
     fprintf( stderr, "rpit_socket_client_update: expecting NULL pointer arg.\n" );
  
	while ( 1 )	{
		
		usleep( RPIT_SOCKET_PERIOD );
		
		/* Get time before sending request */
		
		clock_gettime( CLOCK_MONOTONIC, &before_time );
    
    /* Check if socket exists */
    
    if ( !sfd )
      continue;
		
		/* 
			Send MAGIC datagram, and read response from server.
		*/

		if ( write( sfd, RPIT_SOCKET_MAGIC, strlen( RPIT_SOCKET_MAGIC ) + 1 ) != strlen( RPIT_SOCKET_MAGIC ) + 1 )
			fprintf( stderr, "rpit_socket_client_update: partial/failed write.\n" );
		
		nread = read( sfd, (char*)&local_mes, sizeof( local_mes ) );
		
		/* Get time after receiving response */
		
		clock_gettime( CLOCK_MONOTONIC, &after_time );
		
		/* Compute round-trip duration */
		
		period = (unsigned long long)after_time.tv_sec * 1000000000
					 + (unsigned long long)after_time.tv_nsec
				 - ( (unsigned long long)before_time.tv_sec * 1000000000
					 + (unsigned long long)before_time.tv_nsec );
		if ( period / 1000 > 2 * RPIT_SOCKET_PERIOD )
			fprintf( stderr, "rpit_socket_client_update: laggy connection. Round-trip duration : %llu us\n", period / 1000 );
		
		if ( nread == -1 ) {
			perror("rpit_socket_client_update: read");
		}
		else
		{
			if ( nread != sizeof( local_mes ) )
				fprintf( stderr, "rpit_socket_client_update: received %zd bytes instead of %zd\n", nread, sizeof( local_mes ) );
			else
			{
				/* Update mes */
        
        pthread_mutex_lock( &mes_mutex );
        memcpy( &mes, &local_mes, sizeof( mes ) );
        pthread_mutex_unlock( &mes_mutex );
        
        /* Display measurements */
        
				#ifdef RPIT_SOCKET_DISPLAY_MES
				printf( "> Timestamp : %llu\n", mes.timestamp );
				for ( i = 0; i < RPIT_SOCKET_N; i++ )
					printf( "> mes[%d] = %e\n", i, mes.mes[i] );
        #endif
			}	
		}
	}
	
	return NULL;
}


/*
 * rpit_socket_client_init : initialize communication with the server
 */
void rpit_socket_client_init( uint8_T IP1, uint8_T IP2, uint8_T IP3, uint8_T IP4 )	{
	struct addrinfo 			hints;
	struct addrinfo 			*result, *rp;
	int 									s, i;
	struct timeval 				tv;
  char                  IP[RPIT_SIZEOF_IP];
  
  /* Compute IP address */
  
  snprintf( IP, RPIT_SIZEOF_IP, "%d.%d.%d.%d", IP1, IP2, IP3, IP4 );

	/* Initialize mutex */
	
	pthread_mutex_init( &mes_mutex, NULL );
	
	/* Clear mes structure */
	
	mes.timestamp = 0;
	for ( i = 0; i < RPIT_SOCKET_N; i++ )
		mes.mes[i] = 0.0;

	/* Obtain address(es) matching host/port */

	memset( &hints, 0, sizeof( struct addrinfo ) );
	hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
	hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
	hints.ai_flags = 0;
	hints.ai_protocol = 0;          /* Any protocol */

	s = getaddrinfo( IP, RPIT_SOCKET_PORT, &hints, &result );
	if ( s != 0 ) {
		fprintf( stderr, "rpit_socket_client: function getaddrinfo returned: %s\n", gai_strerror( s ) );
		return;
	}
	
	/* 
		getaddrinfo() returns a list of address structures.
		Try each address until we successfully connect(2).
		If socket(2) (or connect(2)) fails, we (close the socket
		and) try the next address.
	*/

	for ( rp = result; rp != NULL; rp = rp->ai_next )	{
		sfd = socket( rp->ai_family, rp->ai_socktype, rp->ai_protocol );
		if ( sfd == -1 )
			continue;

		if ( connect( sfd, rp->ai_addr, rp->ai_addrlen ) != -1 )
			break;									/* Success */

		close( sfd );
	}

	if ( rp == NULL )	{					/* No address succeeded */
		fprintf( stderr, "rpit_socket_client: could not connect. Aborting.\n" );
		return;
	}

	freeaddrinfo( result );			/* No longer needed */
	
	/* Set socket timeout */
	
	tv.tv_sec =		0;
	tv.tv_usec = 	RPIT_SOCKET_TIMEOUT;
	setsockopt( sfd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(struct timeval) );
	
	/* Start thread */
	
	pthread_create( &mes_thread, NULL, rpit_socket_client_update, (void*) NULL );
  
  /* Wait for 10 periods so that the periodic thread can update the measurement */
  
  usleep( 10 * RPIT_SOCKET_PERIOD );

}
 
/* 
 * rpit_socket_client_close : close communication with the server
 */
void rpit_socket_client_close( void )	{

	/* Shutdown thread */
	
	pthread_cancel( mes_thread );
	
	/* Close socket */
	
	close( sfd );
	sfd = 0;
}
#endif
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void rpi_sfun_socket_Outputs_wrapper(real_T *y  , 
                          const real_T  *rpi_Ts, const int_T  p_width0, 
                          const uint8_T  *rpi_IP1, const int_T  p_width1, 
                          const uint8_T  *rpi_IP2, const int_T  p_width2, 
                          const uint8_T  *rpi_IP3, const int_T  p_width3, 
                          const uint8_T  *rpi_IP4,  const int_T p_width4)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/* Output computation */
  
  #ifdef MATLAB_MEX_FILE

  y[0] = 0.0;
  y[1] = 0.0;
  y[2] = 0.0;
  y[3] = 0.0;
  y[4] = 0.0;
  y[5] = 0.0;
  y[6] = 0.0;
  y[7] = 0.0;
  y[8] = 0.0;
  y[9] = 0.0;

  #else
          
  static int                initialized = 0;
  
  if ( ( p_width1 != 1 ) || 
       ( p_width2 != 1 ) ||
       ( p_width3 != 1 ) ||
       ( p_width4 != 1 ) )
    fprintf( stderr, "** Parameters inconsistency **\n" );

  if ( p_width0 > 1 )	{
    fprintf( stderr, "** Multiple rates not allowed in this block **\n" );
    y[0] = 0.0;
    y[1] = 0.0;
    y[2] = 0.0;
    y[3] = 0.0;
    y[4] = 0.0;
    y[5] = 0.0;
    y[6] = 0.0;
    y[7] = 0.0;
    y[8] = 0.0;
    y[9] = 0.0;
    return;
  }

  if ( *rpi_Ts < 0.002 )	{
    fprintf( stderr, "** Max sampling rate = 500Hz **\n" );
    y[0] = 0.0;
    y[1] = 0.0;
    y[2] = 0.0;
    y[3] = 0.0;
    y[4] = 0.0;
    y[5] = 0.0;
    y[6] = 0.0;
    y[7] = 0.0;
    y[8] = 0.0;
    y[9] = 0.0;
    return;
  }
  
  if ( !initialized ) {
    rpit_socket_client_init( *rpi_IP1, *rpi_IP2, *rpi_IP3, *rpi_IP4 );
    initialized = 1;
  }
  
  pthread_mutex_lock( &mes_mutex );
  y[0] = (real_T)mes.mes[0];
  y[1] = (real_T)mes.mes[1];
  y[2] = (real_T)mes.mes[2];
  y[3] = (real_T)mes.mes[3];
  y[4] = (real_T)mes.mes[4];
  y[5] = (real_T)mes.mes[5];
  y[6] = (real_T)mes.mes[6];
  y[7] = (real_T)mes.mes[7];
  y[8] = (real_T)mes.mes[8];
  y[9] = (real_T)mes.mes[9];
  pthread_mutex_unlock( &mes_mutex );
  
  #endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
