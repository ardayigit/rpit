/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Fri Jan  3 18:32:12 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

#ifndef MATLAB_MEX_FILE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/i2c-dev.h>
#include "MPU-9150.h"
#endif
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
#ifndef MATLAB_MEX_FILE

#define IMUPI_DEVNAME             "/dev/i2c-1"
#define IMUPI_BLOCK_SIZE          6
#define IMUPI_NB_AXIS             3
#define IMUPI_I2C_AUTO_INCREMENT  0x80
#define IMUPI_A_GAIN              6.103515625e-05
#define IMUPI_G_GAIN              0.030487804878049
#define IMUPI_M_GAIN              0.3001221001221001
#define IMUPI_GOFF_NB_ITER        50
#define IMUPI_INIT_DELAY          100000
#define IMUPI_CONFIG_DELAY        10000
#define IMUPI_RESET_TIMEOUT       100

#define IMUPI_NO_ERROR            0
#define IMUPI_I2C_OPEN_ERROR      1
#define IMUPI_I2C_DEV_NOT_FOUND   2
#define IMUPI_I2C_WRITE_ERROR     3
#define IMUPI_I2C_READ_ERROR      4
#define IMUPI_INIT_ERROR          5

int             imupi_dev         = -1;
unsigned char   mpu_9150_address  = MPU_9150_I2C_ADDRESS_1;
double  g_off[IMUPI_NB_AXIS]      = { 0.0, 0.0, 0.0 };

/*
 *  imupi_read: read all sensor values on the board and return them as double.
 */
int mpu9150pi_read( double *a, double *g, double *m ) {
  uint8_t         block[IMUPI_BLOCK_SIZE];
  int             ret, i;
  static double   last_m[3] = { 0.0, 0.0, 0.0 };
  static int      mag_state = 0;
  static uint8_t  mblock[IMUPI_BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0 };
  
  a[0] = a[1] = a[2] = g[0] = g[1] = g[2] = m[0] = m[1] = m[2] = 0.0;
  
  if ( imupi_dev == -1 )
    return IMUPI_INIT_ERROR;
    
  /* Read accelerations */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, mpu_9150_address ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  if ( i2c_smbus_read_i2c_block_data( imupi_dev, IMUPI_I2C_AUTO_INCREMENT | MPU_9150_ACCEL_XOUT_H, IMUPI_BLOCK_SIZE, block ) != IMUPI_BLOCK_SIZE )
    return IMUPI_I2C_READ_ERROR;
  
  a[0] = (double)( (int16_t)( block[0] << 8 | block[1] ) * IMUPI_A_GAIN );
  a[1] = (double)( (int16_t)( block[2] << 8 | block[3] ) * IMUPI_A_GAIN );
  a[2] = (double)( (int16_t)( block[4] << 8 | block[5] ) * IMUPI_A_GAIN );
  
  
  /* Read gyro */
  
  if ( i2c_smbus_read_i2c_block_data( imupi_dev, IMUPI_I2C_AUTO_INCREMENT | MPU_9150_GYRO_XOUT_H, IMUPI_BLOCK_SIZE, block ) != IMUPI_BLOCK_SIZE )
    return IMUPI_I2C_READ_ERROR;
  
  g[0] = (double)( (int16_t)( block[0] << 8 | block[1] ) * IMUPI_G_GAIN ) - g_off[0];
  g[1] = (double)( (int16_t)( block[2] << 8 | block[3] ) * IMUPI_G_GAIN ) - g_off[1];
  g[2] = (double)( (int16_t)( block[4] << 8 | block[5] ) * IMUPI_G_GAIN ) - g_off[2];
  
  
  /* Read magnetometer */

  if ( ioctl( imupi_dev, I2C_SLAVE, MPU_9150_I2C_MAGN_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;

  /* Read sequentially X, Y and Z to avoid too long delays */
  
  switch( mag_state ) {
    
    case 0:
      // Check if data is ready.

      ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_ST1 );
        
      if ( ret < 0 )
        return IMUPI_I2C_READ_ERROR;
      
      if ( ret & 0x01 ) {
        mag_state = 1;
      }
      
      // Duplicate last measurements
      m[0] = last_m[0];
      m[1] = last_m[1];
      m[2] = last_m[2];
      break;
    
    case 1:
      // Read X axis

      for ( i = 0; i < 2; i++ )  {
        ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_HXL + i );
        if ( ret < 0 )
          return IMUPI_I2C_READ_ERROR;
        mblock[i] = ret;
      }
      mag_state = 2;
      
      // Duplicate last measurements
      m[0] = last_m[0];
      m[1] = last_m[1];
      m[2] = last_m[2];
      break;
      
    case 2:
      // Read Y axis

      for ( i = 2; i < 4; i++ )  {
        ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_HXL + i );
        if ( ret < 0 )
          return IMUPI_I2C_READ_ERROR;
        mblock[i] = ret;
      }
      mag_state = 3;
      
      // Duplicate last measurements
      m[0] = last_m[0];
      m[1] = last_m[1];
      m[2] = last_m[2];
      break;
    
    case 3:
      // Read Z axis

      for ( i = 4; i < 6; i++ )  {
        ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_HXL + i );
        if ( ret < 0 )
          return IMUPI_I2C_READ_ERROR;
        mblock[i] = ret;
      }
      
      m[1] = (double)( (int16_t)( mblock[1] << 8 | mblock[0] ) * IMUPI_M_GAIN );
      m[0] = (double)( (int16_t)( mblock[3] << 8 | mblock[2] ) * IMUPI_M_GAIN );
      m[2] = -(double)( (int16_t)( mblock[5] << 8 | mblock[4] ) * IMUPI_M_GAIN );
      
      last_m[0] = m[0];
      last_m[1] = m[1];
      last_m[2] = m[2];
      
      // Re-arm single measurement mode
      if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_CNTL, 0x01 ) == -1 )
        return IMUPI_I2C_WRITE_ERROR;
        
      mag_state = 0;
      break;
      
    default:
      mag_state = 0;
  }
  
  return IMUPI_NO_ERROR;
}

/*
 *  imupi_init: initialize the board registers.
 */
int mpu9150pi_init( void )  {
  double  dummy_a[IMUPI_NB_AXIS], g[IMUPI_NB_AXIS], dummy_m[IMUPI_NB_AXIS];
  double  offset[IMUPI_NB_AXIS] = { 0.0, 0.0, 0.0 };
  int     ret, i;
  
  /* Open I2C device */
  
  imupi_dev = open( IMUPI_DEVNAME, O_RDWR );  
  if ( imupi_dev == -1 )
    return IMUPI_I2C_OPEN_ERROR;
    
  /* Initialize Invensens board */
    
  /* Initialize accelerometer and gyro */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, mpu_9150_address ) < 0 )  {
    mpu_9150_address  = MPU_9150_I2C_ADDRESS_2;
    if ( ioctl( imupi_dev, I2C_SLAVE, mpu_9150_address ) < 0 )
      return IMUPI_I2C_DEV_NOT_FOUND;
  }
  
  // Device reset
  
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_PWR_MGMT_1, 0x80 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  i = 0;
  do {
    ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_PWR_MGMT_1 );
    if ( ret < 0 )
      return IMUPI_I2C_READ_ERROR;
    usleep( IMUPI_CONFIG_DELAY );
  } while( ( ret & 0x80 ) && ( ++i < IMUPI_RESET_TIMEOUT ) );
  if ( i == IMUPI_RESET_TIMEOUT )
    return IMUPI_INIT_ERROR;
  
  // Disbale sleep mode, gyro X clock source: 0b00000001
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_PWR_MGMT_1, 0x01 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // 1 kHz sampling rate: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_SMPRT_DIV, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // No ext sync, DLPF at 44Hz for the accel and 42Hz for the gyro: 0b00000011
  // No ext sync, DLPF at 260Hz for the accel and 256Hz for the gyro: 0b00000000
  // No ext sync, DLPF at 10Hz for the accel and 10Hz for the gyro: 0b00000101
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_DEFINE, 0x05 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Disable all FIFOs: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_FIFO_EN, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Bypass mode enabled: 0b00000010
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_INT_PIN_CFG, 0x02 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Disable all interrupts: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_INT_ENABLE, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // No FIFO and no I2C slaves: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_USER_CTRL, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Wait for initialization to complete
  usleep( IMUPI_INIT_DELAY );
  
  // Gyro range at +/-1000 °/s: 0b00010000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_GYRO_CONFIG, 0x10 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
    
  // Accel range at +/-2g: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_ACCEL_CONFIG, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  /* Initialize magnetometer */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, MPU_9150_I2C_MAGN_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;

  // Check for the AKM device ID
  ret = i2c_smbus_read_byte_data( imupi_dev, MPU_9150_WIA );
  if ( ret < 0 )
    return IMUPI_I2C_READ_ERROR;
  if ( ret != MPU_9150_AKM_ID )
    return IMUPI_I2C_DEV_NOT_FOUND;

  // Single measurement mode: 0b00000001
  if ( i2c_smbus_write_byte_data( imupi_dev, MPU_9150_CNTL, 0x01 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  /* Wait for initialization to complete */
  
  usleep( IMUPI_INIT_DELAY );
  
  /* Test data reading */
  
  if ( mpu9150pi_read( dummy_a, g, dummy_m ) )
      return IMUPI_INIT_ERROR;

  /* Calculate gyro offsets */
  
  for ( i = 0; i < IMUPI_GOFF_NB_ITER; i++ )  {
    if ( mpu9150pi_read( dummy_a, g, dummy_m ) )
      return IMUPI_INIT_ERROR;

    offset[0] += g[0];
    offset[1] += g[1];
    offset[2] += g[2];
  }
  
  g_off[0] = offset[0] / IMUPI_GOFF_NB_ITER;
  g_off[1] = offset[1] / IMUPI_GOFF_NB_ITER;
  g_off[2] = offset[2] / IMUPI_GOFF_NB_ITER;
   
  return IMUPI_NO_ERROR;
}

/*
 *  imupi_terminate: close i2c device.
 */
void mpu9150pi_terminate( void )  {
  
  if ( imupi_dev != -1 )  {
    close( imupi_dev );
    imupi_dev = -1;
  }
}

#endif
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void rpi_sfun_mpu9150_Outputs_wrapper(real_T *ax,
                          real_T *ay,
                          real_T *az,
                          real_T *gx,
                          real_T *gy,
                          real_T *gz,
                          real_T *mx,
                          real_T *my,
                          real_T *mz, 
                           const real_T  *rpi_Ts, const int_T p_width0)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/* Output computation */
  
  #ifdef MATLAB_MEX_FILE

  ax[0] = 0.0;
  ay[0] = 0.0;
  az[0] = 0.0;
  gx[0] = 0.0;
  gy[0] = 0.0;
  gz[0] = 0.0;
  mx[0] = 0.0;
  my[0] = 0.0;
  mz[0] = 0.0;

  #else
          
  int     status;
  real_T  a[IMUPI_NB_AXIS], g[IMUPI_NB_AXIS], m[IMUPI_NB_AXIS];

  if ( p_width0 > 1 )	{
    fprintf( stderr, "** Multiple rates not allowed in this block **\n" );
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
    return;
  }

  if ( *rpi_Ts < 0.002 )	{
    fprintf( stderr, "** Max sampling rate = 500Hz **\n" );
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
    return;
  }

  status = mpu9150pi_read( a, g, m );

  if ( status ) {
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
  }
  else  {
    ax[0] = a[0];
    ay[0] = a[1];
    az[0] = a[2];
    gx[0] = g[0];
    gy[0] = g[1];
    gz[0] = g[2];
    mx[0] = m[0];
    my[0] = m[1];
    mz[0] = m[2];
  }
  #endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
