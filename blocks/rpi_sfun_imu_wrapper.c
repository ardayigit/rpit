/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue Oct 22 16:54:09 2013
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

#ifndef MATLAB_MEX_FILE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/i2c-dev.h>
#include "L3G.h"
#include "LSM303.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
#ifndef MATLAB_MEX_FILE

#define IMUPI_DEVNAME             "/dev/i2c-1"
#define IMUPI_BLOCK_SIZE          6
#define IMUPI_NB_AXIS             3
#define IMUPI_I2C_AUTO_INCREMENT  0x80
#define IMUPI_A_GAIN              6.103515625e-05
#define IMUPI_G_GAIN              0.0152587890625
#define IMUPI_MXY_GAIN            0.000909090909091
#define IMUPI_MZ_GAIN             0.00102040816327
#define IMUPI_GOFF_NB_ITER        50

#define IMUPI_NO_ERROR            0
#define IMUPI_I2C_OPEN_ERROR      1
#define IMUPI_I2C_DEV_NOT_FOUND   2
#define IMUPI_I2C_WRITE_ERROR     3
#define IMUPI_I2C_READ_ERROR      4
#define IMUPI_INIT_ERROR          5

int     imupi_dev                 = -1;
real_T  g_off[IMUPI_NB_AXIS]      = { 0.0, 0.0, 0.0 };

/*
 *  imupi_read: read all sensor values on the board and return them as double.
 */
int imupi_read( real_T *a, real_T *g, real_T *m ) {
  uint8_t block[IMUPI_BLOCK_SIZE];
  int     ret;
  
  a[0] = a[1] = a[2] = g[0] = g[1] = g[2] = m[0] = m[1] = m[2] = 0.0;
  
  if ( imupi_dev == -1 )
    return IMUPI_INIT_ERROR;
    
  /* Read accelerations */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, LSM303_ACC_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  if ( i2c_smbus_read_i2c_block_data( imupi_dev, IMUPI_I2C_AUTO_INCREMENT | LSM303_OUT_X_L_A, IMUPI_BLOCK_SIZE, block ) != IMUPI_BLOCK_SIZE )
    return IMUPI_I2C_READ_ERROR;
  
  a[0] = (real_T)( (int16_t)( block[1] << 8 | block[0] ) * IMUPI_A_GAIN );
  a[1] = (real_T)( (int16_t)( block[3] << 8 | block[2] ) * IMUPI_A_GAIN );
  a[2] = (real_T)( (int16_t)( block[5] << 8 | block[4] ) * IMUPI_A_GAIN );
  
  /* Read gyro */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, L3GD20_GYR_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  if ( i2c_smbus_read_i2c_block_data( imupi_dev, IMUPI_I2C_AUTO_INCREMENT | L3G_OUT_X_L, IMUPI_BLOCK_SIZE, block ) != IMUPI_BLOCK_SIZE )
    return IMUPI_I2C_READ_ERROR;
  
  g[0] = (real_T)( (int16_t)( block[1] << 8 | block[0] ) * IMUPI_G_GAIN ) - g_off[0];
  g[1] = (real_T)( (int16_t)( block[3] << 8 | block[2] ) * IMUPI_G_GAIN ) - g_off[1];
  g[2] = (real_T)( (int16_t)( block[5] << 8 | block[4] ) * IMUPI_G_GAIN ) - g_off[2];
  
  /* Read magnetometer */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, LSM303_MAG_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  /* Check if data is ready */
  
  while( 1 )  {
    ret = i2c_smbus_read_byte_data( imupi_dev, LSM303_SR_REG_M );
    
    if ( ret < 0 )
      return IMUPI_I2C_READ_ERROR;
    
    // Check the DRDY bit
    if ( ( ret & 0x01 ) )
      break;
  }
  
  if ( i2c_smbus_read_i2c_block_data( imupi_dev, IMUPI_I2C_AUTO_INCREMENT | LSM303_OUT_X_H_M, IMUPI_BLOCK_SIZE, block ) != IMUPI_BLOCK_SIZE )
    return IMUPI_I2C_READ_ERROR;
  
  // NB: X, Z, Y axis order for magnetometer readings
  m[0] = (real_T)( (int16_t)( block[0] << 8 | block[1] ) * IMUPI_MXY_GAIN );
  m[2] = (real_T)( (int16_t)( block[2] << 8 | block[3] ) * IMUPI_MZ_GAIN );
  m[1] = (real_T)( (int16_t)( block[4] << 8 | block[5] ) * IMUPI_MXY_GAIN );
  
  return IMUPI_NO_ERROR;
}

/*
 *  imupi_init: initialize the board registers.
 */
int imupi_init( void )  {
  real_T  dummy_a[IMUPI_NB_AXIS], g[IMUPI_NB_AXIS], dummy_m[IMUPI_NB_AXIS];
  real_T  offset[IMUPI_NB_AXIS] = { 0.0, 0.0, 0.0 };
  int     i;
  
  /* Open I2C device */
  
  imupi_dev = open( IMUPI_DEVNAME, O_RDWR );  
  if ( imupi_dev == -1 )
    return IMUPI_I2C_OPEN_ERROR;
    
  /* Initialize Pololu board */
    
  /* Initialize accelerometer */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, LSM303_ACC_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  // Reboot memory content: 0b10000000
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_CTRL_REG5_A, 0x80 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // 400Hz DR, normal mode, all axis enabled: 0b01110111
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_CTRL_REG1_A, 0x77 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Update when reading, big endian, +/-2g, high resolution output mode: 0b10001000
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_CTRL_REG4_A, 0x88 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  /* Initialize gyro */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, L3GD20_GYR_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  // Reboot memory content, disable fifo, disable HP filter, no int, select LPF1 output: 0b10000000
  if ( i2c_smbus_write_byte_data( imupi_dev, L3G_CTRL_REG5, 0x80 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
    
  // 760Hz DR, 30Hz BW, normal mode, all axis enabled: 0b11001111
  if ( i2c_smbus_write_byte_data( imupi_dev, L3G_CTRL_REG1, 0xCF ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  // Update when reading, big endian, 500dps: 0b10010000
  if ( i2c_smbus_write_byte_data( imupi_dev, L3G_CTRL_REG4, 0x90 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  /* Initialize magnetometer */
  
  if ( ioctl( imupi_dev, I2C_SLAVE, LSM303_MAG_ADDRESS ) < 0 )
    return IMUPI_I2C_DEV_NOT_FOUND;
  
  // Temperature sensor disabled, 220Hz DR: 0b00011100
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_CRA_REG_M, 0x1C ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
    
  // Gain +/- 1.3G: 0b00100000
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_CRB_REG_M, 0x20 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
    
  // Continuous conversion mode: 0b00000000
  if ( i2c_smbus_write_byte_data( imupi_dev, LSM303_MR_REG_M, 0x00 ) == -1 )
    return IMUPI_I2C_WRITE_ERROR;
  
  /* Calculate gyro offsets */
  
  // One fake read to filter out border effects
  if ( imupi_read( dummy_a, g, dummy_m ) )
    return IMUPI_INIT_ERROR;
    
  for ( i = 0; i < IMUPI_GOFF_NB_ITER; i++ )  {
    if ( imupi_read( dummy_a, g, dummy_m ) )
      return IMUPI_INIT_ERROR;

    offset[0] += g[0];
    offset[1] += g[1];
    offset[2] += g[2];
  }
  
  g_off[0] = offset[0] / IMUPI_GOFF_NB_ITER;
  g_off[1] = offset[1] / IMUPI_GOFF_NB_ITER;
  g_off[2] = offset[2] / IMUPI_GOFF_NB_ITER;
    
  return IMUPI_NO_ERROR;
}

/*
 *  imupi_terminate: close i2c device.
 */
void imupi_terminate( void )  {
  
  if ( imupi_dev != -1 )  {
    close( imupi_dev );
    imupi_dev = -1;
  }
}

#endif

/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void rpi_sfun_imu_Outputs_wrapper(real_T *ax,
                          real_T *ay,
                          real_T *az,
                          real_T *gx,
                          real_T *gy,
                          real_T *gz,
                          real_T *mx,
                          real_T *my,
                          real_T *mz, 
                           const real_T  *rpi_Ts, const int_T p_width0)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
  
  /* Output computation */
  
  #ifdef MATLAB_MEX_FILE

  ax[0] = 0.0;
  ay[0] = 0.0;
  az[0] = 0.0;
  gx[0] = 0.0;
  gy[0] = 0.0;
  gz[0] = 0.0;
  mx[0] = 0.0;
  my[0] = 0.0;
  mz[0] = 0.0;

  #else
          
  int     status;
  real_T  a[IMUPI_NB_AXIS], g[IMUPI_NB_AXIS], m[IMUPI_NB_AXIS];

  if ( p_width0 > 1 )	{
    fprintf( stderr, "** Multiple rates not allowed in this block **\n" );
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
    return;
  }

  if ( *rpi_Ts < 0.002 )	{
    fprintf( stderr, "** Max sampling rate = 500Hz **\n" );
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
    return;
  }

  status = imupi_read( a, g, m );

  if ( status ) {
    ax[0] = 0.0;
    ay[0] = 0.0;
    az[0] = 0.0;
    gx[0] = 0.0;
    gy[0] = 0.0;
    gz[0] = 0.0;
    mx[0] = 0.0;
    my[0] = 0.0;
    mz[0] = 0.0;
  }
  else  {
    ax[0] = a[0];
    ay[0] = a[1];
    az[0] = a[2];
    gx[0] = g[0];
    gy[0] = g[1];
    gz[0] = g[2];
    mx[0] = m[0];
    my[0] = m[1];
    mz[0] = m[2];
  }
  #endif
  
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
