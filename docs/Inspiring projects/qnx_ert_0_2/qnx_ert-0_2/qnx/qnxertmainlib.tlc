%% 
%% 
%%
%% Copyright 1994-2012 The MathWorks, Inc.
%%
%% Abstract:
%%   Library file to create a sample main for ERT code format
%%   for a given model.
%%
%selectfile NULL_FILE

%include "ertmain_grtinterface.tlc"

%function FcnMdlName() void
  %return Name
%endfunction

%function FcnNumST() void
  %return NumSynchronousSampleTimes
%endfunction

%function FcnGetPublicModelHeaderFile() void
  %return "%<Name>.h"
%endfunction

%function FcnGetPeriodFromTID(tid) void
  %return SampleTime[tid].ClockTickStepSize
%endfunction

%function FcnIsERTMalloc() void
  %assign isERTMalloc = TLC_FALSE
  %% Please comment out this line to get back default ert target.
  %assign isERTMalloc = TLC_FALSE && ...
     MultiInstanceERTCode && ...
    !GenerateErtSFunction && !GenerateClassInterface && ...
    !ExportFunctionsMode && !GenerateGRTWrapper
  %return isERTMalloc
%endfunction

%function FcnGenerateRtOneStep(callSite) 
  %assign rootSystem = System[NumSystems-1]
  %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")
  
  %if GenerateClassInterface 
    %assign paramProto = "void"
    %assign paramName = ""
  %elseif FcnIsERTMalloc()
    %assign paramProto = "model_data_struct* modelData"
    %assign paramName =  "modelData"
  %elseif !reqInsts.SimStructInst && !EmptyRealTimeObject
    %assign paramProto = "%<tSimStructType> *const %<tSimStruct>"
    %assign paramName = "%<tSimStruct>"
  %else
    %assign paramProto = "void"
    %assign paramName = ""
  %endif
 
  %if (callSite) 
    %return "rt_OneStep(%<paramName>)"
  %else
    %% generate function definition if it's not called from callSite
    %openfile fcnAbstract
%<FcnRTOneStepDescription()>\
    %closefile fcnAbstract
    %createrecord fcnRec {Name "rt_OneStep"; Returns "void"; Params paramProto; Abstract fcnAbstract; ...
      Category "model"; GeneratedBy "ertmainlib.tlc"; Type "Utility"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %assign fcnBanner = SLibDumpFunctionBanner(fcnRec)
    %assign fcnProtoType = "void rt_OneStep(%<paramProto>)"
    %undef fcnRec
    %return fcnBanner + "\n" + fcnProtoType
  %endif
%endfunction

%function FcnGenerateRtMdlPtr()
  %assign rootSystem = System[NumSystems-1]
  %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")

  %openfile retBuf
  %if FcnIsERTMalloc() && ...
    !reqInsts.SimStructInst && !EmptyRealTimeObject 
    %<tSimStructType> *%<tSimStruct> = &(modelData->%<tSimStruct>);
  %endif
  %closefile retBuf
  %return retBuf
%endfunction
%%
%% Functions for creating the appropriate scheduler
%%

%function FcnGenerateModelInitialize() Output
  /* Initialize model */
  %if !GenerateClassInterface
    %<SLibModelInitFcnName()>(%<SLibModelFcnArgs("Initialize",TLC_TRUE,"")>);
  %else %%in class gen mode
    %<::CPPObjectName>.initialize();
  %endif
%endfunction

%function FcnGenerateModelRegistration() Output
  %assert UsingMalloc
  
  %assign fcnParams = SLibModelFcnArgs("Registration",TLC_TRUE,"")
  /* Allocate model data */
  %<tSimStruct> = %<Name>(%<fcnParams>);
%endfunction

%function FcnGenerateModelTerminate() Output
    
  /* Disable rt_OneStep() here */

  %if IncludeMdlTerminateFcn
    /* Terminate model */
    %if !GenerateClassInterface
      %<FcnMdlName()>_terminate(%<SLibModelFcnArgs("Terminate",TLC_TRUE,"")>);
    %else
      %<::CPPObjectName>.terminate();
    %endif
  %endif
%endfunction

%function ERTSimulateOneStep() Output
  %%  Simulate the model step behavior if 
  %%  1. The MAT-file logging is selected;
  %%  2. External Mode option is selected;
  %%  3. ForceSimulatedRTOneStep is set;
  %%  4. StopReqestedFlag is accessed.
  %assign forceOneStep = EXISTS("ForceSimulatedRTOneStep")
  
  %assign simulateStep = MatFileLogging || ExtMode || ...
    EXISTS("ForceSimulatedRTOneStep") || RTMStopReqAccessed()

  %return simulateStep
%endfunction

%function ERTStopCheck() Output
  %if RTMStopReqAccessed()
    %if TargetOS == "VxWorksExample"
      %% use inverse logic
      %assign stopCheck = "(%<RTMGetErrStat()> != %<SLibGetNullDefinitionFromTfl()>) || %<RTMGetStopRequested()>"
    %else
      %assign stopCheck = "(%<RTMGetErrStat()> == %<SLibGetNullDefinitionFromTfl()>) && !%<RTMGetStopRequested()>"
    %endif
  %else
    %if TargetOS == "VxWorksExample"
      %% use inverse logic
      %assign stopCheck = "%<RTMGetErrStat()> != %<SLibGetNullDefinitionFromTfl()>"
    %else
      %assign stopCheck = "%<RTMGetErrStat()> == %<SLibGetNullDefinitionFromTfl()>"
    %endif
  %endif
  
  %return stopCheck
%endfunction

%function PrintERTStopCheckStatus() Output
  %openfile retBuf
  %if RTMStopReqAccessed()
    fprintf(stderr,"Error status: %s; Stop request: %d \n", %<RTMGetErrStat()>,%<RTMGetStopRequested()>);
  %else
    fprintf(stderr,"Error status: %s \n", %<RTMGetErrStat()>);
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction

%function ERTGenCodeRunOneStep(simstructArg) Output
  %openfile retBuf
  %if ERTSimulateOneStep()
    %if MatFileLogging
      /* The MAT-file logging option selected; therefore, simulating 
      * the model step behavior (in non real-time).  Running this
      * code produces results that can be loaded into MATLAB.
      */
      %assign simulateStep = TLC_TRUE
    %elseif ExtMode
      /* The External Mode option selected; therefore,
      *  simulating the model step behavior (in non real-time). 
      */
      %assign simulateStep = TLC_TRUE
    %elseif RTMStopReqAccessed()
      /* Simulating the model step behavior (in non real-time) to
      *  simulate model behavior at stop time.
      */
      %assign simulateStep = TLC_TRUE
    %elseif EXISTS("ForceSimulatedRTOneStep")
      /* Simulating step behavior */
      %assign simulateStep = TLC_TRUE
    %endif
    while (%<ERTStopCheck()>) {
    %if ExtMode
      %assign buffsRec   = ::CompiledModel.CachedCodeBuffsForRootSys
      %if ISFIELD(buffsRec,"ExtModeHeader") && !WHITE_SPACE(buffsRec.ExtModeHeader)
        %<buffsRec.ExtModeHeader>\
      %endif
      %<FcnGenerateExtModeOneStep()>
    %endif
      %<FcnGenerateRtOneStep(TLC_TRUE)>;
    }
  %else
    %assign period = FcnGetPeriodFromTID(0)
    /* Attach rt_OneStep to a timer or interrupt service routine with
    * period %<period> seconds (the model's base sample time) here.  The
    * call syntax for rt_OneStep is 
    *
    *  %<FcnGenerateRtOneStep(TLC_TRUE)>;
    */
    printf("Warning: The simulation will run forever. "
    "Generated ERT main won't simulate model step behavior. "
    "To change this behavior select the 'MAT-file logging' option.\n");
    fflush(%<SLibGetNullDefinitionFromTfl()>);
    
    %if GenerateClassInterface && (!RealTimeModelAccessed)
      while(1) {
        /*  Perform other application tasks here */
        }
    %else
      while (%<ERTStopCheck()>) {
        /*  Perform other application tasks here */
      } 
    %endif

  %endif
  %closefile retBuf
  
  %return retBuf
  
%endfunction

%function FcnSimpleNonOSMain() Output
  %assign fcnReturns = "int_T"
  %assign fcnParams = "int_T argc, const char *argv[]"
  %if ::CompiledModel.StandaloneSubsystemTesting == 2
    %% The following file is in test/toolbox/rtw/targets/ert/standalone_subsystem
    %include "standalonetesting.tlc"
    %% If the standalone testing is on, we test memory initialization.
    %<FcnGenMainForMemInitTesting()>
    %assign fcnName = "main1"
    %assign fcnAbstract = ""
  %else
    %assign fcnName = "main"
    %openfile fcnAbstract
The example "main" function illustrates what is required by your
application code to initialize, execute, and terminate the generated code.
Attaching rt_OneStep to a real-time clock is target specific.  This example
illustates how you do this relative to initializing the model.
    %closefile fcnAbstract
  %endif
  
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
    Category "main"; GeneratedBy "ertmainlib.tlc"; Type "Main"}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<fcnReturns> %<fcnName>(%<fcnParams>)
  {
    %assign rootSystem = System[NumSystems-1]
    %assign reqInsts = LibGetSystemField(rootSystem, "ReqRootPrmHdrDataInsts")
    %assign needRTMdl = !reqInsts.SimStructInst && !::CompiledModel.EmptyRealTimeObject
    %assign needMdlParam = !reqInsts.ParamsInst && ...
      !SLibPrmBufferIsEmpty("SimulinkGlobal", "Instance")
    %if FcnIsERTMalloc()
      model_data_struct *modelData;
      %if needRTMdl
        %<tSimStructType> *%<tSimStruct>;
      %endif
      modelData = (model_data_struct*) malloc(sizeof(*modelData));
      %if needRTMdl
        %<tSimStruct> = &(modelData->%<tSimStruct>);
      %endif
      %if needMdlParam
        modelData->%<LibGetParametersStruct()> = %<LibGetParametersStruct()>;
      %endif
    %endif
   
    %if UsingMalloc
      %assert needRTMdl
      %<tSimStructType> *%<tSimStruct>;
    %endif
    
    %if ExtMode == 1

      /* External mode */
      rtERTExtModeParseArgs(argc, argv);
    %else
      
      /* Unused arguments */
      (void)(argc);
      (void)(argv);
    %endif

    %if needRTMdl
      %assign simstructArg = tSimStruct
    %else
      %assign simstructArg = ""
    %endif
    
    %if UsingMalloc
      
      %<FcnGenerateModelRegistration()>
      
      if (%<simstructArg> == NULL) {
        (void)fprintf(stderr,"Memory allocation error during model "
        "registration");
        return(1);
      }
      %if !SuppressErrorStatus
        if (rtmGetErrorStatus(%<simstructArg>) != NULL) {
          (void)fprintf(stderr,"Error during model registration: %s\n",
          rtmGetErrorStatus(%<simstructArg>));
          %<FcnGenerateModelTerminate()>
          return(1);
        }      
      %endif
      
    %elseif MultiInstanceERTCode && !GenerateClassInterface
      
      %% Pack model data into RTM
      %<FcnPackModelDataIntoRTM()>      
    %endif
    
    %if MatFileLogging && SeparateRegistrationFcn      
      /* Matfile logging */
      %<SLibGenLoggingStart()>      
    %endif
    
    %<FcnGenerateModelInitialize()>

    %if ExtMode
      %<SLibGenERTExtModeInit()>
    %endif   
    
    %<ERTGenCodeRunOneStep(simstructArg)>

    %% If SuppressErrorStatus is true, RTMGetErrStat() 
    %% is always (void 0). The following code is 
    %% dead code. Should not generate
    %openfile tmpbuf    
    
    %if MatFileLogging
      /* Matfile logging */
      %<SLibGenLoggingStop("MATFILE")>
    %endif
    
    %if ExtMode
      /* External mode */
      rtExtModeShutdown(%<NumSynchronousSampleTimes>);
    %endif
    
    %<FcnGenerateModelTerminate()>
    %closefile tmpbuf
    %if SuppressErrorStatus && !RTMStopReqAccessed() 
      %if !WHITE_SPACE(tmpbuf)
        /* The option 'Suppress error status in real-time model data structure' 
        * is selected, therefore the following code does not need to execute.
        */
        #if 0
        %<tmpbuf>
        #endif
      %endif
    %else
      %<tmpbuf>\
    %endif
    return 0;
  }
%endfunction

%function GetErtModelFcnArgs(fcn,isCallSite,tid)
  %assign updateContStates = ...
    (ISEQUAL(tid,0) || ISEQUAL(tid, "")) && (NumContStates > 0)
  %switch fcn
    %case "OutputUpdate"
      %if updateContStates
        %assign argList = SLibModelFcnArgs("UpdateContStates",isCallSite,tid)
      %else
        %assign argList = SLibModelFcnArgs("OutputUpdate",isCallSite,tid)
      %endif
      %break
    %case "Update"
      %if updateContStates
        %assign argList = SLibModelFcnArgs("UpdateContStates",isCallSite,tid)
      %else
        %assign argList = SLibModelFcnArgs("RootUpdate",isCallSite,tid)
      %endif
      %break
    %default
      %assign argList = SLibModelFcnArgs(fcn,isCallSite,tid)
      %break
  %endswitch
  %return argList
%endfunction

%function FcnCallMdlStep(tid) Output
  %if GenerateSampleERTMain && SLibIsAsyncTaskOnlyModel() && ...
    !LibIsDeploymentDiagram()
    %% step function is empty, does not exist.
    %return 
  %endif
  %assign outputReturn = ""
  %assign updateFcnName = ""
  %assign updateArgList = ""
      
  %assign OriginalGenerateSampleERTMain = ConfigSet.GenerateSampleERTMain
  %if LibIsDeploymentDiagram() && (GenerateSampleERTMain || ...
    OriginalGenerateSampleERTMain || RateBasedStepFcn) && (!SLibGenerateNativeThreads())
    %<SLibDeploymentCallERTEntryPoints(tid)>
  %else
     %if (GenerateSampleERTMain || OriginalGenerateSampleERTMain || RateBasedStepFcn)...
      && SLibIsRateGrouping() && (!SLibGenerateNativeThreads())
      %assign tidSuffix = tid
    %else
      %assign rootSystem.CurrentTID = ""
      %assign tidSuffix = ""
    %endif
    
    %if CombineOutputUpdateFcns
      %assign outputReturn = SLibModelStepFcnReturn("ReturnIdentifier")
      %assign outputFcnName = SLibModelStepFcnName(tidSuffix)
      %assign outputArgList = GetErtModelFcnArgs("OutputUpdate",TLC_TRUE,tid)
    %else
      %assign outputFcnName = "%<Name>_output%<tidSuffix>"
      %assign outputArgList = GetErtModelFcnArgs("Output",TLC_TRUE,tid)
      %assign updateFcnName = "%<Name>_update%<tidSuffix>"
      %assign updateArgList = GetErtModelFcnArgs("Update",TLC_TRUE,tid)
    %endif
    %if !ISEMPTY(outputReturn)
      %assign outputReturn  = outputReturn + " = "
    %endif
    %<outputReturn> %<outputFcnName>(%<outputArgList>);
    /* Get model outputs here */
    
    %if updateFcnName != ""
      %assign buffsRec   = ::CompiledModel.CachedCodeBuffsForRootSys
      %if ExtMode == 1
        %assign rootSystem = System[NumSystems-1]
        %assign isRateGrouping = SLibIsMultiRateAndRateGrouping(rootSystem)
        %if !isRateGrouping
          %assign tidTemp = ""
        %else
          %assign tidTemp = tid
        %endif
        %if ISFIELD(buffsRec,"ExtModeTrailer%<tidTemp>") && ...
          !WHITE_SPACE(buffsRec.ExtModeTrailer%<tidTemp>)
          %assign tmpBuff = buffsRec.ExtModeTrailer%<tidTemp>
          %<tmpBuff>\
        %endif   
      %endif
      %if MatFileLogging
        %if ISEQUAL(tid, "") || ISEQUAL(tid, 0)
          %if ISFIELD(buffsRec,"LogBuffer") && !WHITE_SPACE(buffsRec.LogBuffer)
            %<buffsRec.LogBuffer>\
          %endif
        %endif
      %endif
      %<updateFcnName>(%<updateArgList>);
    %endif
  %endif
%endfunction

%function FcnRTOneStepDescription() Output
Associating rt_OneStep with a real-time clock or interrupt service routine
is what makes the generated code "real-time".  The function rt_OneStep is
always associated with the base rate of the model.  Subrates are managed
by the base rate from inside the generated code.  Enabling/disabling
interrupts and floating point context switches are target specific.  This
example code indicates where these should take place relative to executing
the generated code step function.  Overrun behavior should be tailored to
your application needs.  This example simply sets an error status in the
real-time model and returns from rt_OneStep.
%endfunction

%function FcnSingleRateWithoutOS() void
  
  %<SLibCacheCodeToFile("mainSrc_data_defn", ...
    LibERTMainDeclareVariables(TLC_TRUE,TLC_TRUE))>
  %openfile tmpFcnBuf
  %% Comments generation by FcnRTOneStepDescription is moved inside FcnGenerateRtOneStep
  %<FcnGenerateRtOneStep(TLC_FALSE)>
  {
    static boolean_T OverrunFlag = 0;
    %<SLibDeclareFcnProtoCtlVariables()>\

    %<FcnGenerateRtMdlPtr()>
    /* Disable interrupts here */

    /* Check for overrun */
    if (OverrunFlag) {
      %if GenerateClassInterface
        %if RealTimeModelAccessed
          %if !SuppressErrorStatus
          rtmSetErrorStatus(%<CPPObjectName>.getRTM(), "Overrun");
          %endif
        %endif
      %else
        %if !SuppressErrorStatus
	%<RTMSetErrStat("\"Overrun\"")>;
        %endif
      %endif
	return;
    }
    OverrunFlag = TRUE;
    
    /* Save FPU context here (if necessary) */
    /* Re-enable timer or interrupt here */
    /* Set model inputs here */

    /* Step the model */
    %<FcnCallMdlStep("")>\

    /* Indicate task complete */ 
    OverrunFlag = FALSE;

    /* Disable interrupts here */
    /* Restore FPU context here (if necessary) */
    /* Enable interrupts here */

    %if ExtMode == 1
      rtExtModeCheckEndTrigger();
    %endif
  }
  
  %<FcnSimpleNonOSMain()>\
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction %% SingleRateWithoutOS

%function LibInitStr(length) void
  %assign initStr = ""
  %assign comma   = ""
  %foreach idx = length
    %assign initStr = initStr + "%<comma>0"
    %assign comma = ","
  %endforeach
  %return "{%<initStr>}"
%endfunction


%function FcnMultiRateSingletaskingWithoutOS() void
  
  %<SLibCacheCodeToFile("mainSrc_data_defn", ...
    LibERTMainDeclareVariables(TLC_TRUE,TLC_TRUE))>
  %openfile tmpFcnBuf
  
  %<FcnGenerateRtOneStep(TLC_FALSE)>
  {
    static boolean_T OverrunFlag = FALSE;
     %<SLibDeclareFcnProtoCtlVariables()>\
    
     %<FcnGenerateRtMdlPtr()>
     /* Disable interrupts here */

    /* Check for overrun */
    
    if (OverrunFlag) {
      %if !SuppressErrorStatus
      %<RTMSetErrStat("\"Overrun\"")>;
      %endif
      return;
    }
    OverrunFlag = TRUE;
    /* Save FPU context here (if necessary) */
    /* Re-enable timer or interrupt here */
    /* Set model inputs here */

    /* Step the model for base rate */
    %<FcnCallMdlStep(0)>\

    /* Indicate task complete */
    OverrunFlag = FALSE;

    /* Disable interrupts here */
    /* Restore FPU context here (if necessary) */
    /* Enable interrupts here */

    %if ExtMode == 1
      rtExtModeCheckEndTrigger();
    %endif
  }

  %<FcnSimpleNonOSMain()>\
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%function ERTMainCheckRTMTaskRunsThisBaseStep(idx)
  %if SuppressMultiTaskScheduler
    %return "(taskCounter[%<idx>] == 0)"
  %else
    %return "((boolean_T)%<RTMTaskRunsThisBaseStep(idx)>)"
  %endif
%endfunction

%function ERTMainGenSchedulerCode()
  %openfile retBuf
  %if SuppressMultiTaskScheduler
    %% scheduler code in main 
    %foreach i = NumSynchronousSampleTimes-1
      %assign limit = FcnComputeTaskTickLimit(i+1)
      taskCounter[%<i+1>]++;
      if (taskCounter[%<i+1>] == %< FcnComputeTaskTickLimit(i+1)>) {
        taskCounter[%<i+1>]=0;
        }
    %endforeach
  %endif
  %closefile retBuf
  
  %return retBuf
%endfunction

%function EventFlagsFunction(fcnPref,eventflags)
  %openfile tmpBuf
  %if InlineSetEventsForThisBaseRateFcn
    %assign tid01Eq = FixedStepOpts.TID01EQ
    %if LibGetNumSyncPeriodicTasks() > 2
      for (i = %<1+tid01Eq>; i < %<FcnNumST()>; i++) {
        if %<ERTMainCheckRTMTaskRunsThisBaseStep("i")> {
          if (%<eventflags>[i]) {
            OverrunFlags[0] = FALSE;
            OverrunFlags[i] = TRUE;
            %if !SuppressErrorStatus
              /* Sampling too fast */
              %<LibSetRTModelErrorStatus("\"Overrun\"")>;
            %endif
            return;
          } 
          %<eventflags>[i] = TRUE;
        }
      }
    %elseif LibGetNumSyncPeriodicTasks() == 2
      %assign lstTid = FcnNumST()-1
      if %<ERTMainCheckRTMTaskRunsThisBaseStep(lstTid)> {
        if (%<eventflags>[%<lstTid>]) {
          OverrunFlags[0] = FALSE;
          OverrunFlags[%<lstTid>] = TRUE;
          %if !SuppressErrorStatus
            /* Sampling too fast */
            %<LibSetRTModelErrorStatus("\"Overrun\"")>;
          %endif
          return;
        } 
        %<eventflags>[%<lstTid>] = TRUE;
      }
    %endif
    %<ERTMainGenSchedulerCode()>
  %else
    %assign fcnName = "%<fcnPref>SetEventsForThisBaseStep"
    
    %if MultiInstanceERTCode
      %<fcnName>(%<eventflags>, %<tSimStruct>);
    %else
      %<fcnName>(%<eventflags>);
    %endif
  %endif
  %closefile tmpBuf
  
  %return tmpBuf
%endfunction

%function FcnCallEventFlagsFunction(fcnPref) Output
 
  %if InlineSetEventsForThisBaseRateFcn
    /*
    * For a bare-board target (i.e., no operating system), the 
    * following code checks whether any subrate overruns, 
    * and also sets the rates that need to run this time step.  
    */
    %<EventFlagsFunction(fcnPref,"eventFlags")>
  %else
    /*
    * For a bare-board target (i.e., no operating system), the rates
    * that execute this base step are buffered locally to allow for
    * overlapping preemption.  The generated code includes function
    * %<fcnName>() which sets the rates
    * that need to run this time step.  The return values are 1 and 0
    * for true and false, respectively.
    */
    %<EventFlagsFunction(fcnPref,"eventFlags")>
  %endif
  
%endfunction

%function FcnInitializeTaskCounter()
  %assign initStr = ""
  %assign comma   = ""
  %foreach idx = NumSynchronousSampleTimes
    %assign initStr = initStr + "%<comma>%<FcnComputeTaskTickOffset(idx)>"
    %assign comma = ","
  %endforeach
  %return "{%<initStr>}"
%endfunction

%% DocFunction{Code Configuration Functions}: LibERTMainDeclareVariables =============
%% Abstract:
%%   Declare local or global variables used in ERT main function.
%%   
%%   Arguments:
%%       globalVariables: TLC_TRUE to declare global variables, 
%%                        otherwise local variables
%%       bareboard:       TLC_TRUE to declare variables for bareboard ERT main
%%
%function LibERTMainDeclareVariables(globalVariables, bareboard)
  %openfile retBuf
  
  %if !globalVariables
    %if bareboard
      static boolean_T OverrunFlags[%<FcnNumST()>] = %<LibInitStr(NumSynchronousSampleTimes)>;
      %if InlineSetEventsForThisBaseRateFcn
        static  boolean_T eventFlags[%<FcnNumST()>] = %<LibInitStr(NumSynchronousSampleTimes)>; /* Model has %<FcnNumST()> rates */
      %endif
    %endif
    %if SuppressMultiTaskScheduler
      static  int_T taskCounter[%<FcnNumST()>] = %<FcnInitializeTaskCounter()>;
    %endif
    %% local variables
    %if LibNumDiscreteSampleTimes() > 2
      int_T i;
    %endif
    %if !InlineSetEventsForThisBaseRateFcn
      boolean_T eventFlags[%<FcnNumST()>]; /* Model has %<FcnNumST()> rates */
    %endif
  %endif
  %if !globalVariables && bareboard
    %<SLibDeclareFcnProtoCtlVariables()>\
  %endif
  
  %if UsingMalloc && globalVariables && bareboard
    const char *RT_MEMORY_ALLOCATION_ERROR = "memory allocation error"; 
  %endif
  
  %closefile retBuf

  %return retBuf
%endfunction

%function FcnMultiRateMultitaskingWithoutOS() void
 
  %<SLibCacheCodeToFile("mainSrc_data_defn", ...
    LibERTMainDeclareVariables(TLC_TRUE,TLC_TRUE))>
  %openfile tmpFcnBuf
  
  %assign tid01Eq = FixedStepOpts.TID01EQ
  %<FcnGenerateRtOneStep(TLC_FALSE)>
  {
    %<LibERTMainDeclareVariables(TLC_FALSE,TLC_TRUE)>
    %<FcnGenerateRtMdlPtr()>
    
    /* Disable interrupts here */

    /* Check base rate for overrun */
    if (OverrunFlags[0]) {
      %if !SuppressErrorStatus
        %<RTMSetErrStat("\"Overrun\"")>;
      %endif
      return;
    }
    OverrunFlags[0] = TRUE;

    /* Save FPU context here (if necessary) */
    /* Re-enable timer or interrupt here */

    %<FcnCallEventFlagsFunction("%<Name>_")>\
    
    /* Set model inputs associated with base rate here */

    %assign rootSystem.CurrentTID = 0
    /* Step the model for base rate */
    %<FcnCallMdlStep(0)>\
    
    /* Indicate task for base rate complete */
    OverrunFlags[0] = FALSE;
    
    %if LibGetNumSyncPeriodicTasks() > 2
      %% Multiple subrates
      /* Step the model for any subrate */
      for (i = %<1+tid01Eq>; i < %<FcnNumST()>; i++) {
        %if InlineSetEventsForThisBaseRateFcn
          /* If task "i" is running, don't run any lower priority task */
          if (OverrunFlags[i]) {
            return; 
          }
          
        %endif
        if (eventFlags[i]) {
          
          %if !InlineSetEventsForThisBaseRateFcn
            
            if (OverrunFlags[i]) {
              %if !SuppressErrorStatus
                %<RTMSetErrStat("\"Overrun\"")>;
              %endif
              return;
            }
            
          %endif
          OverrunFlags[i] = TRUE;
          
          /* Set model inputs associated with subrates here */
          
          /* Step the model for subrate "i" */
          %if GenerateSampleERTMain && SLibIsRateGrouping() 
            switch(i) {
              %foreach idx = LibGetNumSyncPeriodicTasks() - 1
                %assign tid = idx + 1 + tid01Eq
                case %<tid> :
                %assign rootSystem.CurrentTID = tid
                %<FcnCallMdlStep(tid)>\
                break;
              %endforeach
              default : 
              break;
            }
          %else
            %<FcnCallMdlStep("i")>\
          %endif
          
          /* Indicate task complete for sample time "i" */
          OverrunFlags[i] = FALSE;
          %if InlineSetEventsForThisBaseRateFcn
            eventFlags[i] = FALSE;
          %endif
        }
      }
    %else

      %% Single subrate
      %assign tid = FcnNumST()-1
      %if InlineSetEventsForThisBaseRateFcn
        /* If task 1 is running, don't run any lower priority task */
        if (OverrunFlags[1]) {
          return; 
        }
        
      %endif
      /* Step the model for subrate */
      if (eventFlags[%<tid>]) { 
      %if !InlineSetEventsForThisBaseRateFcn
        if (OverrunFlags[%<tid>]) {
          %if !SuppressErrorStatus
            %<RTMSetErrStat("\"Overrun\"")>;
          %endif
          return;
        }
      %endif
      OverrunFlags[%<tid>] = TRUE;
      
      /* Set model inputs associated with subrates here */
      
      %assign rootSystem.CurrentTID = tid
      /* Step the model for subrate %<tid> */
      %<FcnCallMdlStep(tid)>\
      
      /* Indicate task complete for subrate */
      OverrunFlags[%<tid>] = FALSE; 
      %if InlineSetEventsForThisBaseRateFcn
        eventFlags[%<tid>] = FALSE;
      %endif
      }    
    %endif

    /* Disable interrupts here */
    /* Restore FPU context here (if necessary) */
    /* Enable interrupts here */
    
    %if ExtMode == 1
      /* Ext mode check end trigger */
      rtExtModeCheckEndTrigger();
    %endif
  }

  %<FcnSimpleNonOSMain()>\
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction


%function FcnGenerateMultitaskingOSCode() Output
  %assign tid01Eq = FixedStepOpts.TID01EQ
  %foreach i = LibGetNumSyncPeriodicTasks() - 1
    %assign tid = i + 1 + tid01Eq
    %assign rootSystem.CurrentTID = tid
    %assign fcnName = "tSubRate_%<tid>"
    %assign fcnReturns = "static int_T"
    %assign fcnParams = "threadStructT  *thPtr"
    %assign fcnAbstract = ""
    %assign fcnCategory = "main"
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
      Abstract fcnAbstract; Category fcnCategory; GeneratedBy "ertmainlib.tlc"; Type "Step"}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<fcnReturns> %<fcnName>(%<fcnParams>)
    {
      %<SLibDeclareFcnProtoCtlVariables()>\
      int_T                   rcvid;
      my_message_t            msg;
      printf(" %<fcnName> started; priority is %d\n", getprio(0));
      while(1) {        
         //printf ("channelId is %d; priority is %d\n", thPtr->channelId, thPtr->priority); 
	     //rcvid = MsgReceive(thPtr->channelId, &msg, sizeof(msg), NULL);
         sem_wait(thPtr->sem);
		/* Set model inputs associated to subrate here */
        
        /* Step the model for sample time for tid */ 
        if (thPtr->thExecCount == 0) {
           thPtr->thExecCount++;
            //printf("Stepping %s\n","%<fcnName>");
			%<FcnCallMdlStep(tid)>\
           thPtr->thExecCount--;
        }
        else {
           thPtr->timeOutCount++;
        }

        /* Write model outputs associated to subrate here */
      }
      return(1);
    }
  %endforeach
  %<LibERTMainDeclareVariables(TLC_TRUE,TLC_FALSE)>
  %assign fcnName = "tBaseRate"
  %assign fcnReturns = "static int_T"
  %assign fcnParams = "threadStructT  *thPtr"
  %assign fcnAbstract = ""
  %assign fcnCategory = "main"
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
    Abstract fcnAbstract; Category fcnCategory; GeneratedBy "ertmainlib.tlc"}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<fcnReturns> %<fcnName>(%<fcnParams>)
  {
    %<LibERTMainDeclareVariables(TLC_FALSE,TLC_FALSE)>
    struct                  sigevent         event;
    struct                  itimerspec       itime;
    timer_t                 timer_id;
    my_message_t            msg;
    int                     chid;
    int_T                     rcvid;
    real_T                  minorStep;
    real_T                  lval_nsec;
    int_T                   msgStat;
    int_T                   i;
   
    //printf("Executing tBaseRate\n");
    event.sigev_notify = SIGEV_PULSE;
    event.sigev_coid = ConnectAttach(ND_LOCAL_NODE, 0, 
                                   thPtr->channelId, 
                                    _NTO_SIDE_CHANNEL, 0);
    event.sigev_priority = getprio(0);
    event.sigev_code = MY_PULSE_CODE;
   
    timer_create(CLOCK_REALTIME, &event, &timer_id);

    %assign period = FcnGetPeriodFromTID(0)

    minorStep = %<period> * 1000000;  
    itime.it_value.tv_sec = (int_T)(minorStep/1000000);
    lval_nsec = fmod((real_T)minorStep,((real_T)1000000.0)) * 1000.0;
    itime.it_value.tv_nsec = (long long)lval_nsec;
    itime.it_interval.tv_nsec = (long long)lval_nsec;
#if 0
    printf("minorStep is %f\n", minorStep);
    printf("lval_nsec is %f\n", lval_nsec);
    printf ("tv_nsec is %d\n", itime.it_value.tv_nsec);
    printf ("tv_sec  is %d\n", itime.it_interval.tv_sec);
#endif


    timer_settime(timer_id, 0, &itime, NULL);    

    while(1) {
      if (%<ERTStopCheck()>) {
        %<PrintERTStopCheckStatus()>
#ifdef EXT_MODE
	      sem_post(startStopSem);
#endif
	     return(1);
       }
        
       //printf("tBaseRate waiting for timer\n");
       rcvid = MsgReceive(thPtr->channelId, &msg, sizeof(msg), NULL);
       //printf("tBaseRate unblocked\n");
      
      %assign firstSubrateTID = 1 + tid01Eq
      %if LibGetNumSyncPeriodicTasks() > 2
        %% multiple subrates
        %assign ifarg = ERTMainCheckRTMTaskRunsThisBaseStep("i")
        for (i = %<firstSubrateTID>; i < %<FcnNumST()>; i++) {

			if %<ifarg> {

              #if 0
              msgStat = MsgSendPulse (GBLthreadArr[i].channelId,
                         sched_get_priority_max( SCHED_RR)  /*  GBLthreadArr[i].priority */,
                           GBL_CMD_START_THREAD,
                           GBL_CMD_START_THREAD);
              #endif
              sem_post(GBLthreadArr[i].sem);
              
			}
		}
      %else
        %% Single subrate
	%assign ifarg = ERTMainCheckRTMTaskRunsThisBaseStep("%<firstSubrateTID>")
	if %<ifarg> {
       #if 0
       MsgSendPulse (GBLthreadArr[%<firstSubrateTID>].channelId,
                       GBLthreadArr[%<firstSubrateTID>].priority,
                       GBL_CMD_START_THREAD,
                       GBL_CMD_START_THREAD);
       #endif
       sem_post(GBLthreadArr[i].sem);
	}
      %endif
       
      %<ERTMainGenSchedulerCode()>
      
      /* Set model inputs associated with base rate here */
  
      if (thPtr->thExecCount == 0) {
         /* Step the model for base rate */
         thPtr->thExecCount++;
         %<FcnCallMdlStep(0)>\
         thPtr->thExecCount--;
      }
      else {
        thPtr->timeOutCount++;
      }
            
    %if ExtMode == 1
      /* External mode */
      rtExtModeCheckEndTrigger();
    %endif
    }
  }
%endfunction

%function FcnGenerateSingletaskingOSCode() Output
  %assign fcnName = "tBaseRate"
  %assign fcnReturns = "static int_T"
  %assign fcnParams = "threadStructT  *thPtr"
  %assign fcnAbstract = ""
  %assign fcnCategory = "main"
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
    Abstract fcnAbstract; Category fcnCategory; GeneratedBy "ertmainlib.tlc"}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<fcnReturns> %<fcnName>(%<fcnParams>)
  {
    int_T i;
    %<SLibDeclareFcnProtoCtlVariables()>\
    struct                  sigevent         event;
    struct                  itimerspec       itime;
    timer_t                 timer_id;
    my_message_t            msg;
    int                     chid;
    int                     rcvid;
    real_T                  minorStep;
    real_T                  lval_nsec;
    event.sigev_notify = SIGEV_PULSE;
    event.sigev_coid = ConnectAttach(ND_LOCAL_NODE, 0, 
                                   thPtr->channelId, 
                                    _NTO_SIDE_CHANNEL, 0);
    event.sigev_priority = getprio(0);
    event.sigev_code = MY_PULSE_CODE;

#if 1   
   
    timer_create(CLOCK_REALTIME, &event, &timer_id);

    %assign period = FcnGetPeriodFromTID(0)
    minorStep = %<period> * 1000000;  
    itime.it_value.tv_sec = (int_T)(minorStep/1000000);
    lval_nsec = fmod((real_T)minorStep,((real_T)1000000.0)) * 1000.0;
    itime.it_value.tv_nsec = (long long)lval_nsec;
    itime.it_interval.tv_nsec = (long long)lval_nsec;

#else

    timer_create(CLOCK_REALTIME, &event, &timer_id);
    %assign period = FcnGetPeriodFromTID(0)
    minorStep = %<period> * 1000000;
    printf("minorStep is %f\n", minorStep);
    itime.it_value.tv_sec = (int_T)(minorStep/1000000);
    lval_nsec = fmod((real_T)minorStep,((real_T)1000000.0)) * 1000.0;
    printf("lval_nsec is %f\n", lval_nsec);
    itime.it_value.tv_nsec = (long long)lval_nsec;
    itime.it_interval.tv_sec = (int_T)(minorStep/1000000);

    itime.it_interval.tv_nsec = (long long)lval_nsec;
#endif

    timer_settime(timer_id, 0, &itime, NULL);    

    while(1) {
      if (%<ERTStopCheck()>) {
        %<PrintERTStopCheckStatus()>
	sem_post(startStopSem);
	return(1);
      }
      
      rcvid = MsgReceive(thPtr->channelId, &msg, sizeof(msg), NULL);
        
      /* Set model inputs here */
      
      /* Step the model */
      if (thPtr->thExecCount == 0) {
        thPtr->thExecCount++;
      %if FcnNumST() > 1
        %<FcnCallMdlStep(0)>\
      %else
         %<FcnCallMdlStep("")>\
      %endif
        thPtr->thExecCount--;
       }
       else {
         thPtr->timeOutCount++;
       }
      %if ExtMode == 1
        /* External mode */
        rtExtModeCheckEndTrigger();
      %endif

    }

    return(1);
  }
%endfunction

%function FcnSchedulerWithOS() void
  %assign singleTasking = SLibSingleTasking()
  %openfile tmpFcnBuf
  /* ANSI C headers */
  #include <float.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <ctype.h>
  
  /* QNX headers */
    #include <stdlib.h>
    #include <stdio.h>
    #include <pthread.h>
    #include <sched.h>
    #include <assert.h>
    #include <fcntl.h>
    #include <sys/procfs.h>
    #include <sys/states.h>
    #include <sys/types.h>
    #include <sys/neutrino.h>
    #include <sys/netmgr.h>
    #include <sys/syspage.h>
    #include <sys/socket.h>
    #include <sys/siginfo.h>
    #include <rpc/rpc.h>
    #include <netdb.h>
    #include <netinet/in.h>
    #include <netinet/tcp.h>
    #include <process.h>
    #include <string.h>
    #include <math.h>
    #include <unistd.h>
    #include <semaphore.h>


  typedef struct threadStructTag {
     char*           name;
     int_T           channelId;
     sem_t*          sem;
     pthread_t       threadId;
     int_T           priority;
     int_T           thExecCount;
     int_T           timeOutCount;
  }threadStructT;
  
  
  static threadStructT  GBLthreadArr[%<FcnNumST()>];

  /* this sets the standard stack size for spawned tasks used by the model.
   * this can be changed by compiling with '-DSTACK_SIZE=nnn' where nnn is
   * the stack size desired.
   */
  #define START_STOP_SEM_NAME  "startStopSem"
  #ifndef STACK_SIZE
  #define STACK_SIZE 16384
  #endif
  #define  GBL_CMD_START_THREAD  1000
  #define  GBL_START_PRIORITY  20
  #define MY_PULSE_CODE   _PULSE_CODE_MINAVAIL
  typedef union {
        struct _pulse   pulse;
        /* your other message structures would go 
           here too */
  } my_message_t;

  %% VxWorks needs this as a global
  sem_t   *startStopSem;  
  %if ExtMode
    %assign fcnName = "PrintUsageMsg"
    %assign fcnReturns = "static void"
    %assign fcnParams = "void"
    %openfile fcnAbstract
Print message describing the usage of rt_main (i.e., how it should be
invoked - API).
    %closefile fcnAbstract
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "main"; GeneratedBy "ertmainlib.tlc"; Type "Utility"}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<fcnReturns> %<fcnName>(%<fcnParams>);
    %<fcnReturns> %<fcnName>(%<fcnParams>)
    {
      printf("\nInvalid command line arguments:\n");
      printf(
      "Usage: "
      "\t %<FcnMdlName()>_main(priority, port, optStr, port)\n\nwhere:\n\n"
      "\tint_T  priority     The task priority for spawned tasks\n"
      "\tint_T  port         The TCP port used for external communication\n"
      "\tchar_T *optStr      Options\n");
      
      printf("optStr is an option string of the form:\n\t"
      "-option1 val1 -option2 val2 -option3\n\n");

      printf("\tValid options are:\n");
      printf("\t-tf 20    - sets final time to 20 seconds\n");
      printf("\t-w        - The simulation waits for the host to connect before starting\n");
    } /* end PrintUsageMsg */
    
    %assign fcnName = "CountStrs"
    %assign fcnReturns = "static int"
    %assign fcnParams = "const char_T *str"
    %assign fcnAbstract = "Count the number of space delimited strings."
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "main"; GeneratedBy "ertmainlib.tlc"; Type "Utility"}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<fcnReturns> %<fcnName>(%<fcnParams>)
    {
      int          count   = 0;
      const char_T *strPtr = str;
      
      while(*strPtr != '\0') {
        /* find substring */
        while (isspace(*strPtr)) strPtr++;
        count++;
        strPtr++;
        
        /* move over this substring */
        while ((!isspace(*strPtr)) && (*strPtr != '\0')) strPtr++;
      }
      return(count);
    } /* end CountStrs */
    
    %assign fcnName = "GetNextStr"
    %assign fcnReturns = "static char_T *"
    %assign fcnParams = "char_T *str, char_T **strPtrNext"
    %openfile fcnAbstract
Assuming an input string that consists of space seperators return a pointer
to the next string, replace the space delimiter with '\0' and return
a pointer to the next non-white space character (or NULL if end of string).

str = "  cat dog";

GetNextStr returns:
    strPtr     = pointer to 'c' (or NULL if no non-space char)
    strPtrNext = pointer to 'd' (or NULL if end of string)
    %closefile fcnAbstract
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "main"; GeneratedBy "ertmainlib.tlc"; Type "Utility"}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<fcnReturns>%<fcnName>(%<fcnParams>)
    {
      int_T  done    = TRUE; /* assume */
      char_T *strPtr = %<SLibGetNullDefinitionFromTfl()>; /* assume */
      
      *strPtrNext = %<SLibGetNullDefinitionFromTfl()>; /* assume */
      
      /*
      * Find beginning of this sub-string.
      */
      while (isspace(*str)) {
        str++;
        if (*str == '\0') {
          /* reached end of string */
          goto EXIT_POINT;
        }
      }
      
      strPtr = str++;
      
      /*
      * Find end of this sub-string and make sure that it terminates with '\0'.
      */
      while (!isspace(*str) && (*str != '\0')) {
        str++;
      }
      if (*str != '\0') {
        done = FALSE;
        *str = '\0';
      }
      
      /*
      * Return a pointer to the next subString (or NULL) if at string end.
      */
      if (!done) {
        str++;
        while(isspace(*str)) {
          str++;
          if (*str == '\0') {
            break;
          }
        }
        *strPtrNext = (*str == '\0') ? %<SLibGetNullDefinitionFromTfl()> : str;
      } else {
        *strPtrNext = %<SLibGetNullDefinitionFromTfl()>;
      }
      
      EXIT_POINT:
      return(strPtr);
    } /* end GetNextOptionStr */

  %endif %% ExtMode
  
  %if !singleTasking
    %<FcnGenerateMultitaskingOSCode()>\
  %else
    %<FcnGenerateSingletaskingOSCode()>\
  %endif

  %assign fcnName = "main"
  %assign fcnReturns = "int_T"
  %if ExtMode
    %assign fcnParams = "int_T priority, char_T *optStr,int_T port"
  %else
    %assign fcnParams = "int_T priority"
  %endif
  %openfile fcnAbstract
Spawn %<FcnMdlName()>_main as an independent VxWorks task from your
application code, specifying its O/S priority
  %closefile fcnAbstract
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
    Category "main"; GeneratedBy "ertmainlib.tlc"; Type "Main"}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<fcnReturns> %<fcnName>(%<fcnParams>)
  {
    const char *status;
    %if ExtMode
      %% VxWorks needs to access tstartStopSem from other modules, so it is not
      %% declared in the local scope here
      int    optStrLen  = strlen(optStr);
      int    argc       = 0;
      char_T **argv     = %<SLibGetNullDefinitionFromTfl()>;
    %else
      sem_t  *startStopSem;      
    %endif
    
    optStr = strdup("-w");
    port = 17725;

    %if !ERTSimulateOneStep()
     #if 0
      printf("Warning: The simulation will run forever. "
      "To change this behavior select the 'MAT-file logging' option.\n");
      fflush(%<SLibGetNullDefinitionFromTfl()>);
     #endif
    %endif
    
    %% for VxWorks we need to parse the options string
    %if ExtMode

      /* 
      * Parse option string.
      */
      if ((optStr != %<SLibGetNullDefinitionFromTfl()>) && (optStrLen > 0)) {
        int     i;
        int     count;
        char_T  *thisStr;
        char_T  *nextStr;
        
        /*
        * Convert to lower case.
        */
        for (i=0; i<optStrLen; i++) {
          optStr[i] = tolower(optStr[i]);
        }
        
        /*
        * Convert error string to standard argc and argv format. 
        */
        
        /* count strings and allocate an argv */
        argc = CountStrs(optStr) + 1;

        argv = (char **)calloc(argc,sizeof(char *));
        if (argv == %<SLibGetNullDefinitionFromTfl()>) {
          (void)fprintf(stderr,
          "Memory allocation error while parsing options string.");
          exit(EXIT_FAILURE);
        }
        
        /* populate argv & terminate the individual substrings */
        argv[0] = "dummyProgramName";
        i=1;
        nextStr = optStr;
        while ((nextStr != %<SLibGetNullDefinitionFromTfl()>) && (thisStr = GetNextStr(nextStr, &nextStr)) != %<SLibGetNullDefinitionFromTfl()> && ( i < argc )) {
          argv[i] = thisStr;
          i++;
        }
        
          rtERTExtModeParseArgs(argc, (const char_T **)argv);
          rtExtModeTornadoSetPortInExtUD(port);

        free(argv);
        argv = %<SLibGetNullDefinitionFromTfl()>;
      }
      
    %endif %% ExtMode
    #if 0
    if (priority <= 0 || priority > 255-(%<FcnNumST()>)+1) {
      priority = 30;
    }
    #endif
	
    sem_unlink(START_STOP_SEM_NAME);
    startStopSem = sem_open(START_STOP_SEM_NAME, O_CREAT,S_IRWXU,0);
    
    %<FcnGenerateModelInitialize()>
    
    %if ExtMode
      rtExtModeTornadoStartup(%<RTMGet("RTWExtModeInfo")>,
      %<NumSynchronousSampleTimes>,
      (boolean_T *)&%<RTMGetStopRequested()>,
      priority,
      STACK_SIZE,
      startStopSem);
    %endif
    
    %%priority = sched_get_priority_max(SCHED_RR) -20;

     priority = getprio(0) + %<NumSynchronousSampleTimes> + 2;
     printf("mw_scheduler priority is %d\n", priority);
    %%
    %if !singleTasking
      %assign firstSubrateTID = 1 + FixedStepOpts.TID01EQ
      %foreach i = NumSynchronousSampleTimes - firstSubrateTID
        %assign idx = i + firstSubrateTID
        %assign taskName = "tRate%<idx>"
        
        GBLthreadArr[%<idx>].sem = sem_open("%<taskName>", O_CREAT,S_IRWXU,0);
        GBLthreadArr[%<idx>].thExecCount = 0;
        GBLthreadArr[%<idx>].timeOutCount = 0;
        GBLthreadArr[%<idx>].priority = priority - %<idx>;
        //printf("Channel id  for %<idx> created: %d\n",  GBLthreadArr[%<idx>].channelId);
        
        GBLthreadArr[%<idx>].threadId = tgtCreateThread("%<taskName>",  tSubRate_%<idx>,
                                   &GBLthreadArr[%<idx>], priority - %<idx>,STACK_SIZE);

      %endforeach
    %endif
    GBLthreadArr[0].thExecCount = 0;
    GBLthreadArr[0].timeOutCount = 0;
    GBLthreadArr[0].priority = priority; 
    GBLthreadArr[0].channelId = ChannelCreate(_NTO_CHF_FIXED_PRIORITY);
    GBLthreadArr[0].sem = sem_open("tBaseRate", O_CREAT,S_IRWXU,0);
    %if !singleTasking
        %assign taskName = "tBaseRate"
        GBLthreadArr[0].threadId = tgtCreateThread("%<taskName>",  tBaseRate,
                                   &GBLthreadArr[0], priority,STACK_SIZE);
    %else
        %assign taskName = "tBaseRate"
        GBLthreadArr[0].threadId = tgtCreateThread("%<taskName>",  tBaseRate,
                                   &GBLthreadArr[0], priority, STACK_SIZE);
    %endif
   
    sem_wait(startStopSem);
    
    %if ExtMode
      rtExtModeTornadoCleanup(%<NumSynchronousSampleTimes>);
    %endif

	sem_unlink(START_STOP_SEM_NAME);

    %assign firstSubrateTID = 1 + FixedStepOpts.TID01EQ
    %if (FcnNumST() > firstSubrateTID ) && !singleTasking
      %foreach i = NumSynchronousSampleTimes - firstSubrateTID
        %assign idx = i + firstSubrateTID
        //qnxTaskDelete(QnxTIDs[%<idx>]);
        sem_close(GBLthreadArr[%<i>].sem);
        sem_unlink(GBLthreadArr[%<i>]. name);
      %endforeach
    %endif
    
    %<FcnGenerateModelTerminate()>\
    
    return(EXIT_SUCCESS);
  }
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%function FcnGenerateMainFunctions(retDesc) void
  %assign singleTasking = SLibSingleTasking()
  %assign delim = "*   "
  %if (SLibGenerateNativeThreads() || ...
    ISEQUAL(TargetOS, "NativeThreadsExample"))
    %% Generate threaded ert main. 
    %if !retDesc  
      %assign isPC = FEVAL("ispc")
      %if isPC  
        %include "ertwinthread.tlc"
      %else
        %include "ertposixthread.tlc"
      %endif
    %endif
    %return retDesc ? ...
      "%<delim>Embedded Coder example for multicore system\n" ...
      "%<delim>to be deployed on a operating system.\n" : ...
      SLibGenerateThreadedMain()
    
  %elseif NumSynchronousSampleTimes == 1
    
    %% Single rate
    
    %if TargetOS != "BareBoardExample"
      %return retDesc ? ...
	"%<delim>Embedded Coder example single rate main\n" ...
	"%<delim>to be deployed on a multitasking operating system.\n" : ...
	FcnSchedulerWithOS()
    %else
      %return retDesc ? ...
	"%<delim>Embedded Coder example single rate main assuming\n" ...
	"%<delim>no operating system.\n" : ...
	FcnSingleRateWithoutOS()
    %endif
  
  %elseif !singleTasking
  
    %% Multirate/Multitasking
    
    %if TargetOS != "BareBoardExample"
      %return retDesc ? ...
	"%<delim>Embedded Coder example multiple rate main tailored\n" ...
	"%<delim>to the VxWorks operating system.  This example code contains a\n" ...
	"%<delim>deterministic implementation of a rate monotonic scheduler deployed\n" ...
	"%<delim>on a multitasking operating system.\n" : ...
	FcnSchedulerWithOS()
    %else
      %return retDesc ? ...
	"%<delim>Embedded Coder example multiple rate main assuming\n" ...
	"%<delim>no operating system.  This example code contains a deterministic\n" ...
	"%<delim>implementation of a rate monotonic scheduler.\n" : ...
	FcnMultiRateMultitaskingWithoutOS()
    %endif
  
  %else
  
    %% Multirate/Singletasking
    
    %if TargetOS != "BareBoardExample"
      %return retDesc ? ...
	"%<delim>Embedded Coder example multiple rate main tailored\n" ...
	"%<delim>to the VxWorks operating system.  This example code contains an\n" ...
	"%<delim>inplementation of a singletasking process implemented on a multitasking\n" ...
	"%<delim>operating system.\n" : ...
	FcnSchedulerWithOS()
    %else
      %return retDesc ? ...
	"%<delim>Embedded Coder example multi-rate singletasking\n" ...
	"%<delim>main assuming no operating system.\n" : ...
	FcnMultiRateSingletaskingWithoutOS()
    %endif
  
  %endif
%endfunction

%function SLibCreateSampleMain() void

  %assign ::GeneratingMainFunction = TLC_TRUE
  
  %openfile tmpFcnBuf
  %<SLibDeclareGlobalVariablesForCPPClass()>\
  %if FcnIsERTMalloc()
    %assign typeDef = SLibDeclareModelFcnArgs(TLC_FALSE)
    %<SLibCacheCodeToFile("mdlFcnArgs_typedef", typeDef)>
    %assign reqInsts = LibGetSystemField(rootSystem, "ReqRootPrmHdrDataInsts")
    %assign needMdlParam = !reqInsts.ParamsInst && ...
      !SLibPrmBufferIsEmpty("SimulinkGlobal", "Instance")
    %if needMdlParam
      static %<tParametersType> %<LibGetParametersStruct()> = {
        %<SLibGetPrmBuffer("SimulinkGlobal", "Instance")>
      }; 
    %endif
  %else
    %<SLibDeclareModelFcnArgs(TLC_TRUE)>\
  %endif
  %closefile tmpFcnBuf
  %<SLibCacheCodeToFile("mainSrc_data_defn", tmpFcnBuf)>

  %openfile tmpFcnBuf
  /*
   * Auto generated example main program for model: %<FcnMdlName()>
   *
   * Simulink Coder version : %<Version>
   %if GenerateFullHeader
   * %<CorCPPForBuildLogsandComments()> source code generated on : %<TLC_TIME>
   %endif
   *
   * Description:
   %<FcnGenerateMainFunctions(1)>\
   *
   * For more information:
   *   o Simulink Coder User's Guide
   *   o Embedded Coder User's Guide
   *   o matlabroot/rtw/c/ert/ert_main.c
   %if TargetOS == "VxWorksExample"
   *   o matlabroot/rtw/c/tornado/rt_main.c
   %endif
   *   o Type 'ecodertutorial' in MATLAB
   *
   %if (TargetOS == "BareBoardExample") || (TargetOS == "NativeThreadsExample")
     * For a real-time operating system deployment example, reconfigure the
     * "Target operating system" option to "VxWorksExample".
   %elseif TargetOS == "VxWorksExample"
     * For a bare board (i.e., no real-time operating system) deployment
     * example, reconfigure the "Target operating system" option to
     * "BareBoardExample".
   %else
     %assign errTxt = "Unknown TargetOS: %<TargetOS>"
     %<LibReportFatalError(errTxt)>
   %endif
   */
  %closefile tmpFcnBuf
  
  %<SLibCacheCodeToFile("mainSrc_ban", tmpFcnBuf)>
  %<SLibCacheCodeToFile("mainSrc_fcn_defn", FcnGenerateMainFunctions(0))>
  
  %openfile tmpFcnBuf

  %if  (TargetOS == "BareBoardExample") || (TargetOS == "NativeThreadsExample")
    #include <stdio.h> /* This ert_main.c example uses printf/fflush */
  %endif
  #include "%<FcnGetPublicModelHeaderFile()>" /* Model's header file */
  #include "rtwtypes.h" /* MathWorks types */
  %if ExtMode
    #include "ext_work.h" /* External mode header file */
  %endif
  %if MatFileLogging
    #include "rt_logging.h"
    %if ((::CompiledModel.RTWStatesLogging==1) || (MatFileSignalLogging==1))
      #include "rt_logging_mmi.h"
    %endif
  %endif
  %closefile tmpFcnBuf
  
  %<SLibCacheCodeToFile("mainSrc_incl", tmpFcnBuf)>
  
  %<SLibCacheCodeToFile("mainSrc_defines", LibDeclareERTDefines(NumSystems-1))>

  %assign ::GeneratingMainFunction = TLC_FALSE
%endfunction

